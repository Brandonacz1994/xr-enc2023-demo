{"version":3,"sources":["Babylon_components/SceneComponent.jsx","Modules/Cameras_Module.js","Modules/Lights_Module.js","Modules/Materials_Module.js","Babylon_components/Axes.js","Babylon_components/PlayGround.js","Modules/XR_Module.js","Modules/GizmoInterface.js","Scenes/intro.js","Scenes/tema_1_figuras.js","Scenes/tema_2_posicion_rotacion_escala.js","Scenes/tema_3_transformaciones.js","Modules/AV_module.js","Assets/3Dmodels/bus.gltf","Assets/3Dmodels/SheenChair.glb","Assets/video/videoTextureSample.mp4","Assets/video/SonyVideoDemo.mp4","Assets/video/rickroll.mp4","Assets/audio/software-interface-start.wav","Assets/audio/software-interface-back.wav","Assets/audio/Idle-bus.wav","Assets/audio/door-bus.wav","Scenes/tema_4_assets_interacciones.js","Scenes/tema_5_webxr.js","App.js","reportWebVitals.js","index.js"],"names":["antialias","engineOptions","adaptToDeviceRatio","sceneOptions","onSceneReady","rest","reactCanvas","useRef","useEffect","canvas","current","engine","BABYLON","scene","isReady","console","log","error","onReadyObservable","addOnce","runRenderLoop","render","resize","getEngine","window","addEventListener","dispose","removeEventListener","className","ref","FreeCameraDefault","camera","setTarget","attachControl","HemisphericLight","options","diffuseColor","specularColor","groundColor","undefined","hemisphericlight","intensity","diffuse","FromHexString","specular","MaterialRandom","material","Random","showWorldAxis","size","makeTextPlane","text","color","dynamicTexture","hasAlpha","drawText","plane","CreatePlane","backFaceCulling","diffuseTexture","offsetY","axisX","CreateLines","Zero","position","axisY","axisZ","addInPlaceFromFloats","showLocalAxes","pilot_local_axisX","pilot_local_axisY","pilot_local_axisZ","local_origin","CreateBox","isVisible","parent","PlayGround","playground_width","playground_depth","walls_width","walls_height","ground","CreateGround","width","height","subdivisionsX","subdivisionsY","wallF","depth","set","wallB","wallL","wallR","visibility","checkCollisions","addChild","gridground","clone","y","grid_ground_material","MATERIALS","majorUnitFrequency","minorUnitVisibility","gridRatio","mainColor","lineColor","opacity","XR_Experience","skybox","mesheswithShadows","inmersive_state","reference_floor","IsSessionSupportedAsync","avaliableVR","avaliableAR","xr","createDefaultXRExperienceAsync","disableDefaultUI","disableNearInteraction","disablePointerSelection","disableTeleportation","optionalFeatures","floorMeshes","uiOptions","sessionMode","referenceSpaceType","inputOptions","doNotLoadControllerMeshes","then","xrExperience","advancedTextureFullScreen","GUI","CreateFullscreenUI","LightEstimation","input","xrCamera","setTransformationFromNonVRCamera","activeCamera","baseExperience","onStateChangedObservable","add","XRstate","IN_XR","ENTERING_XR","EXITING_XR","NOT_IN_XR","length","button1","CreateSimpleButton","cornerRadius","background","fontSize","horizontalAlignment","HORIZONTAL_ALIGNMENT_RIGHT","verticalAlignment","VERTICAL_ALIGNMENT_BOTTOM","topInPixels","leftInPixels","onPointerUpObservable","state","enterXRAsync","exitXRAsync","addControl","meshGUI","sideOrientation","DOUBLESIDE","billboardMode","BILLBOARDMODE_ALL","advancedTexture","CreateForMesh","container","thickness","alpha","zIndex","scaleTo","lightEstimation","featuresManager","enableFeature","LIGHT_ESTIMATION","setSceneEnvironmentTexture","createDirectionalLightSource","shadowGenerator","directionalLight","useBlurExponentialShadowMap","blurScale","setDarkness","forEach","mesh","getShadowMap","renderList","push","GizmoInterface","attachedMesh","attachedMesh_mass","holding","gizmoManager","scaleGizmoEnabled","positionGizmoEnabled","rotationGizmoEnabled","boundingBoxGizmoEnabled","gizmos","boundingBoxGizmo","fixedDragMeshBoundsSize","ignoreChildren","usePointerToAttachGizmos","clearGizmoOnEmptyPointerEvent","onPointerObservable","pointerInfo","type","POINTERDOWN","pickInfo","pickedMesh","XRpickable","attachToMesh","physicsImpostor","mass","setMass","POINTERUP","onKeyboardObservable","keydata","KEYDOWN","event","key","otherMeshs","rp","element","pbr","reflectionTexture","cubeTexture","e","HTMLCanvasElement","Cameras_Module","Lights_Module","skyboxMaterial","inclination","playground","Babylon_Components","ammo","enablePhysics","ground_impostor","BoxImpostor","restitution","sphere","CreateSphere","diameter","sphere_impostor","SphereImpostor","box_material","Materials_Module","box","box_impostor","onBeforeRenderObservable","deltaTimeInMillis","getDeltaTime","rotate","Y","rpm","Math","PI","XR_Module","Gizmo","Scene","SceneComponent","id","diameterX","diameterY","diameterZ","cone","CreateCylinder","diameterTop","diameterBottom","tessellation","torus","CreateTorus","subdivisions","x","z","setAbsolutePosition","newSpherePosition","addInPlace","rotation","Tema","setPosition","body","arm","pilot","MergeMeshes","Degrees_to_radians","faceColors","Blue","Red","Green","White","Yellow","Black","box1","box2","mainbox","box4","box5","box6","box7","degrees","scaling","rot_temp","rot_x","rot_y","rot_z","rot_count","a","addRotation","cos","abs","groundMaterial","pilot_with_WORLD_translate","pilot_with_LOCAL_translate","createInstance","direction_traslation_vector","normalize","i","deltaTimeInsecs","translate","WORLD","LOCAL","node_sphere","CoTAxis","CoT_2Axis","CoT_3Axis","CoT","CoT_2","CoT_3","rotating_box","rotating_box_mini","angle_CoT","angle_CoT2","angle_CoT3","angle_box","angle_mini_box","Cot_angle_per_secs","Cot2_angle_per_secs","Cot3_angle_per_secs","rotating_box_angle_per_secs","mini_box_angle_per_secs","absolutePosition","box_follower1","box_follower2","circle_points","total","sin","circle","points","ellipse_points","deltaTheta","theta","ellipse","box_follower1_movement","box_follower2_movement","box_follower_rotation","rotation_per_sec","VideoTextureToMesh","videoUrl","loop","autoPlay","autoUpdateTexture","muted","poster","videoTexture","TRILINEAR_SAMPLINGMODE","videoMaterial","emissiveColor","VideoPlayerTexture","audioUrl","videoTextureSettings","AudioSettings","videoPlaneOptions","spatialSound","distanceModel","maxDistance","refDistance","rolloffFactor","videoPlane","vidPos","video","videoSound","clicked","actionManager","registerAction","OnPickTrigger","play","pause","OnDoublePickTrigger","currentTime","stop","SoundSpatialToMesh","attachToCollider","rootMesh","collider","name","boundingMinMax","getHierarchyBoundingVectors","bounds","max","subtract","min","geometricCenter","scale","copyFrom","setParent","sound","ImportMeshAsync","chair","meshes","assetManager","tasky","addMeshTask","bus","onSuccess","task","loadedMeshes","opendoor_sound","idle_bus","door_bus","OnPickUpTrigger","onError","message","exception","load","videoSize","AV_module","video3","videoCube","audio_back","OnPickDownTrigger","audio_start","video2","shadowMaterial","receiveShadows","sphere1","segments","sphere2","sphere3","roughness","metallic","realTimeFiltering","realTimeFilteringQuality","TEXTURE_FILTERING_QUALITY_HIGH","setPivotMatrix","Translation","albedoColor","registerBeforeRender","App","exact","path","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","createRoot","document","getElementById"],"mappings":"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","file":"static/js/main.5bd1bf84.chunk.js","sourcesContent":["import { useEffect, useRef } from \"react\";\r\nimport * as BABYLON from \"babylonjs\";\r\nimport \"../App.css\"\r\n\r\nexport default ({ antialias, engineOptions, adaptToDeviceRatio, sceneOptions, onSceneReady, ...rest }) => {\r\n  const reactCanvas = useRef(null);\r\n\r\n  // set up basic engine and scene\r\n  useEffect(() => {\r\n    const { current: canvas } = reactCanvas;\r\n\r\n    if (!canvas) return;\r\n\r\n    const engine = new BABYLON.Engine(canvas, antialias, engineOptions, adaptToDeviceRatio);\r\n    const scene = new BABYLON.Scene(engine, sceneOptions);\r\n\r\n\r\n    if (scene.isReady()) {\r\n      onSceneReady({canvas,scene,engine});\r\n    } else {\r\n      console.log(\"onSceneReady is not avaliable\")\r\n      console.error(\"onSceneReady is not avaliable\")\r\n      scene.onReadyObservable.addOnce((scene) => onSceneReady({canvas,scene,engine}));\r\n    }\r\n\r\n    engine.runRenderLoop(() => {\r\n     \r\n      scene.render();\r\n    });\r\n\r\n    const resize = () => {\r\n      scene.getEngine().resize();\r\n    };\r\n\r\n    if (window) {\r\n      window.addEventListener(\"resize\", resize);\r\n    }\r\n\r\n    return () => {\r\n      scene.getEngine().dispose();\r\n\r\n      if (window) {\r\n        window.removeEventListener(\"resize\", resize);\r\n      }\r\n    };\r\n  }, [antialias, engineOptions, adaptToDeviceRatio, sceneOptions, onSceneReady]);\r\n\r\n  return <canvas className=\"SceneComponent\" ref={reactCanvas} {...rest} />;\r\n};","import * as BABYLON from \"babylonjs\"\r\n\r\n/**\r\n * Defines a default free camera for a babylon js scene\r\n * @param {HTMLCanvasElement} canvas the instanced HTML canvas interface\r\n * @param {BABYLON.Scene} scene the instanced babylon js scene\r\n * @returns the instanced camera\r\n */\r\nexport function FreeCameraDefault(canvas, scene) {\r\n\r\n    // This creates and positions a free camera (non-mesh)\r\n    var camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 5, -10), scene);\r\n\r\n    // This targets the camera to scene origin\r\n    camera.setTarget(new BABYLON.Vector3(0, 1, 0));\r\n\r\n    // This attaches the camera to the canvas\r\n    camera.attachControl(canvas, false);\r\n\r\n    return camera;\r\n}\r\n\r\n/**\r\n * Defines an universal camera for a babylon js scene\r\n * @param {HTMLCanvasElement} canvas the instanced HTML canvas interface\r\n * @param {BABYLON.Scene} scene the instanced babylon js scene\r\n * @returns the instanced camera\r\n */\r\nexport function UniversalCameraDefault(canvas, scene) {\r\n\r\n    // This creates and positions a universal camera (non-mesh)\r\n    var camera = new BABYLON.UniversalCamera(\"camera\", new BABYLON.Vector3(0, 5, -10), scene);\r\n\r\n    // This targets the camera to scene origin\r\n    camera.setTarget(new BABYLON.Vector3(0, 1, 0));\r\n\r\n    // This attaches the camera to the canvas\r\n    camera.attachControl(canvas, false);\r\n\r\n    return camera;\r\n}\r\n\r\n/**\r\n * Defines an Arc rotate camera for a babylon js scene\r\n * @param {HTMLCanvasElement} canvas the instanced HTML canvas interface\r\n * @param {BABYLON.Scene} scene the instanced babylon js scene\r\n * @returns the instanced camera\r\n */\r\nexport function ArcRotateCameraDefault(canvas, scene) {\r\n\r\n    // Creates, angles, distances and targets the ArcRotateCamera\r\n    var camera = new BABYLON.ArcRotateCamera(\"Camera\", 0, 0, 10, new BABYLON.Vector3(0, 0, 0), scene);\r\n\r\n    //This positions the camera\r\n    camera.setPosition(new BABYLON.Vector3(0, 12, -10));\r\n\r\n    // This targets the camera to scene origin\r\n    camera.setTarget(new BABYLON.Vector3(0, 0, 0));\r\n\r\n    // This attaches the camera to the canvas\r\n    camera.attachControl(canvas, false);\r\n\r\n    return camera;\r\n}\r\n\r\n/**\r\n * Defines a default free camera for a babylon js scene\r\n * @param {HTMLCanvasElement} canvas the instanced HTML canvas interface\r\n * @param {BABYLON.Mesh} mesh the mesh to follow\r\n * @param {BABYLON.Scene} scene the instanced babylon js scene\r\n * @returns the instanced camera\r\n */\r\nexport function FollowCameraDefault(canvas, mesh, scene) {\r\n\r\n    //This creates and initially positions a follow camera \t\r\n    var camera = new BABYLON.FollowCamera(\"FollowCam\", new BABYLON.Vector3(0, 10, -10), scene);\r\n\r\n    //The goal distance of camera from target\r\n    camera.radius = 30;\r\n\r\n    // The goal height of camera above local origin (centre) of target\r\n    camera.heightOffset = 10;\r\n\r\n    // The goal rotation of camera around local origin (centre) of target in x y plane\r\n    camera.rotationOffset = 0;\r\n\r\n    //Acceleration of camera in moving from current to goal position\r\n    camera.cameraAcceleration = 0.005\r\n\r\n    //The speed at which acceleration is halted \r\n    camera.maxCameraSpeed = 10\r\n\r\n    //camera.target is set after the target's creation\r\n\r\n    // This targets the camera to scene origin\r\n    camera.setTarget(BABYLON.Vector3.Zero());\r\n\r\n    // This attaches the camera to the canvas\r\n    camera.attachControl(canvas, true);\r\n\r\n    //Set target for camera\r\n    camera.lockedTarget = mesh;\r\n\r\n}","import * as BABYLON from \"babylonjs\"\r\n\r\n\r\n/**\r\n * Point light: Luz que se define como un punto en el espacio.\r\n * @param {String} options.diffuseColor  hex color string (#ffffff)\r\n * @param {String} options.specularColor  hex color string (#ffffff)\r\n * @param {BABYLON.Scene} scene a constructed babylonjs scene\r\n * @returns a constructed point light\r\n */\r\nexport function PointLight(options = { diffuseColor: \"\", specularColor: \"\" }, scene) {\r\n\r\n    options.diffuseColor = options.diffuseColor !== undefined ? options.diffuseColor : \"#ffffff\";\r\n    options.specularColor = options.specularColor !== undefined ? options.specularColor : \"#f5f1ed\";\r\n\r\n\r\n    var pointlight = new BABYLON.PointLight(\"pointlight\", new BABYLON.Vector3(0, 10, 0), scene);\r\n    pointlight.diffuse = new BABYLON.Color3.FromHexString(options.diffuseColor)\r\n    pointlight.specular = new BABYLON.Color3.FromHexString(options.specularColor)\r\n\r\n    return pointlight;\r\n\r\n}\r\n\r\n/**\r\n * Directional light: Luz que representa iluminacion de forma global y absoluta, tiene un rango infinito.\r\n * @param {String} options.diffuseColor a hex color string (#ffffff)\r\n * @param {String} options.specularColor a hex color string (#ffffff)\r\n * @param {BABYLON.Scene} scene a constructed babylonjs scene\r\n * @returns a constructed directional light.\r\n */\r\nexport function DirectionalLight(options = { diffuseColor: \"\", specularColor: \"\" }, scene) {\r\n\r\n    options.diffuseColor = options.diffuseColor !== undefined ? options.diffuseColor : \"#ffffff\";\r\n    options.specularColor = options.specularColor !== undefined ? options.specularColor : \"#f5f1ed\";\r\n\r\n\r\n    var directionallight = new BABYLON.DirectionalLight(\"DirectionalLight\", new BABYLON.Vector3(0, -1, -5), scene);\r\n    directionallight.diffuse = new BABYLON.Color3.FromHexString(options.diffuseColor);\r\n    directionallight.specular = new BABYLON.Color3.FromHexString(options.specularColor);\r\n\r\n    return directionallight;\r\n\r\n}\r\n\r\n/**\r\n * Spot light: luz definida por una posicion, direccion, angulo y un exponente, se define como un cono.\r\n * @param {String} options.diffuseColor a hex color string (#ffffff)\r\n * @param {String} options.specularColor a hex color string (#ffffff)\r\n * @param {BABYLON.scene} scene\r\n * @returns a constructed spotlight\r\n */\r\nexport function SpotLight(options = { diffuseColor: \"\", specularColor: \"\" }, scene) {\r\n\r\n    options.diffuseColor = options.diffuseColor !== undefined ? options.diffuseColor : \"#ffffff\";\r\n    options.specularColor = options.specularColor !== undefined ? options.specularColor : \"#f5f1ed\";\r\n\r\n    //Light direction is directly down from a position one unit up, slow decay\r\n    var SpotLight = new BABYLON.SpotLight(\"spotLight\", new BABYLON.Vector3(3, 4, 0), new BABYLON.Vector3(0, -1, 0), Math.PI / 2, 10, scene);\r\n    SpotLight.diffuse = new BABYLON.Color3.FromHexString(options.diffuseColor);\r\n    SpotLight.specular = new BABYLON.Color3.FromHexString(options.specularColor);\r\n\r\n\r\n    return SpotLight;\r\n\r\n}\r\n\r\n/**\r\n * Hemispheric light: luz definida por una direccion, usualmente hacia arriba (cielo). Permite simular facilmente luz ambiental.\r\n * @param {String} options.diffuseColor a hex color string (#ffffff)\r\n * @param {String} options.specularColor a hex color string (#ffffff)\r\n * @param {String} options.groundColor a hex color string (#ffffff)\r\n * @param {BABYLON.Scene} scene \r\n * @returns a constructed hemispheric light\r\n */\r\nexport function HemisphericLight(options = { diffuseColor: \"\", specularColor: \"\",groundColor:\"\" }, scene) {\r\n\r\n    options.diffuseColor = options.diffuseColor !== undefined ? options.diffuseColor : \"#f0f8ff\";\r\n    options.specularColor = options.specularColor !== undefined ? options.specularColor : \"#237597\";\r\n    options.groundColor = options.groundColor !== undefined ? options.groundColor : \"#010101\";\r\n\r\n    var hemisphericlight = new BABYLON.HemisphericLight(\"hemiLight\", new BABYLON.Vector3(0, 1, 1), scene);\r\n    hemisphericlight.intensity = 0.8;\r\n    hemisphericlight.diffuse = new BABYLON.Color3.FromHexString(options.diffuseColor);\r\n    hemisphericlight.specular = new BABYLON.Color3.FromHexString(options.specularColor);\r\n    hemisphericlight.groundColor = new BABYLON.Color3.FromHexString(options.groundColor);\r\n\r\n    return hemisphericlight;\r\n\r\n}\r\n\r\n/**\r\n * Spot light from a texture example: usando una imagen png de una ventana.\r\n * @param {String} textureImport_URL URL (String) or import of the picture to load as a texture\r\n * @param {BABYLON.Scene} scene\r\n * @returns a constructed spotlight from a texture\r\n */\r\nexport function EmissiveLightFromTexture(textureImport_URL,scene) {\r\n\r\n    var spotLight = new BABYLON.SpotLight(\"spotlight_texture\", new BABYLON.Vector3(10, 15, 10),\r\n        new BABYLON.Vector3(-1, -2, -1), 1.1, 16, scene);\r\n    spotLight.projectionTexture = new BABYLON.Texture(textureImport_URL, scene);\r\n    spotLight.setDirectionToTarget(BABYLON.Vector3.Zero());\r\n    spotLight.intensity = 1.5;\r\n\r\n    return spotLight;\r\n}\r\n\r\n","import * as BABYLON from \"babylonjs\"\r\nimport * as  MATERIALS from \"babylonjs-materials\"\r\n\r\n\r\n/**\r\n * function that generates a random color material\r\n * @param {BABYLON.scene} scene \r\n * @returns the random generated material\r\n */\r\nexport function MaterialRandom(scene) {\r\n    var material = new BABYLON.StandardMaterial(\"material_random\", scene);\r\n    material.diffuseColor = BABYLON.Color3.Random();\r\n\r\n    return material;\r\n}\r\n\r\n\r\n/**\r\n * Helper function to create material from RBG hex string (#ffffff) format\r\n * @param {string} name string name of the instanced material\r\n * @param {string} options.diffuseColor_hex hex color string (#ffffff)\r\n * @param {string} options.specularColor_hex hex color string (#ffffff)\r\n * @param {string} options.emissiveColor_hex hex color string (#ffffff)\r\n * @param {string} options.ambientColor_hex hex color string (#ffffff)\r\n * @param {BABYLON.scene} scene a constructed babylonjs scene\r\n * @returns the generated standard material\r\n */\r\nexport function MaterialFromRGB_Hex(name, options = { diffuseColor_hex: \"\", specularColor_hex: \"\", emissiveColor_hex: '', ambientColor_hex: \"\" }, scene) {\r\n\r\n\r\n    var material = new BABYLON.StandardMaterial(name, scene)\r\n\r\n    if (options.diffuseColor_hex) {\r\n        material.diffuseColor = BABYLON.Color3.FromHexString(options.diffuseColor_hex)\r\n    }\r\n\r\n    if (options.specularColor_hex) {\r\n        material.specularColor = BABYLON.Color3.FromHexString(options.specularColor_hex)\r\n    }\r\n\r\n    if (options.emissiveColor_hex) {\r\n        material.emissiveColor = BABYLON.Color3.FromHexString(options.emissiveColor_hex)\r\n    }\r\n\r\n    if (options.ambientColor_hex) {\r\n        material.ambientColor = BABYLON.Color3.FromHexString(options.ambientColor_hex)\r\n    }\r\n\r\n    return material\r\n}\r\n\r\n\r\n/**\r\n * Helper function to create material from textures (URL format)\r\n * @param {string} name string name of the instanced material\r\n * @param {string} options.diffuseTexture URL (String) or import of the picture to load as a texture\r\n * @param {string} options.specularTexture URL (String) or import of the picture to load as a texture\r\n * @param {string} options.emisissiveTexture URL (String) or import of the picture to load as a texture\r\n * @param {string} options.ambientTexture URL (String) or import of the picture to load as a texture\r\n * @param {BABYLON.scene} scene a constructed babylonjs scene\r\n * @returns the generated material\r\n */\r\nexport function MaterialFromTexture(name, options={ diffuseTexture:\"\", specularTexture:\"\", emisissiveTexture:\"\", ambientTexture:\"\" }, scene) {\r\n\r\n\r\n    var material = new BABYLON.StandardMaterial(name, scene)\r\n\r\n    if (options.diffuseTexture) {\r\n        material.diffuseTexture = new BABYLON.Texture(options.diffuseTexture, scene)\r\n    }\r\n\r\n    if (options.specularTexture) {\r\n        material.specularTexture = new BABYLON.Texture(options.specularTexture, scene)\r\n    }\r\n\r\n    if (options.emisissiveTexture) {\r\n        material.emissiveTexture = new BABYLON.Texture(options.emisissiveTexture, scene)\r\n    }\r\n\r\n    if (options.ambientTexture) {\r\n        material.ambientTexture = new BABYLON.Texture(options.ambientTexture, scene)\r\n    }\r\n\r\n    return material\r\n}\r\n\r\n\r\n","import * as BABYLON from \"babylonjs\"\n\n\n /**\n  * Start world axes in the origin of the world\n  * @param {int} size \n  * @param {BABYLON.Scene} scene \n  */\n export function showWorldAxis (size,scene) {\n    var makeTextPlane = function (text, color, size) {\n        var dynamicTexture = new BABYLON.DynamicTexture(\"DynamicTexture\", 50, scene, true);\n        dynamicTexture.hasAlpha = true;\n        dynamicTexture.drawText(text, 5, 40, \"bold 36px Arial\", color, \"transparent\", true);\n        var plane = new BABYLON.Mesh.CreatePlane(\"TextPlane\", size, scene, true);\n        plane.material = new BABYLON.StandardMaterial(\"TextPlaneMaterial\", scene);\n        plane.material.backFaceCulling = false;\n        plane.material.specularColor = new BABYLON.Color3(0, 0, 0);\n        plane.material.diffuseTexture = dynamicTexture;\n        return plane;\n    };\n\n    var offsetY = 0.02\n\n    var axisX = BABYLON.Mesh.CreateLines(\"axisX\", [\n        new BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95,0, 0.05 * size),\n        new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0, -0.05 * size)\n    ], scene);\n    axisX.color = new BABYLON.Color3(1, 0, 0);\n    var xChar = makeTextPlane(\"X\", \"red\", size / 10);\n    xChar.position = new BABYLON.Vector3(0.9 * size, 0.05 * size, 0);\n    var axisY = BABYLON.Mesh.CreateLines(\"axisY\", [\n        new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),\n        new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)\n    ], scene);\n    axisY.color = new BABYLON.Color3(0, 1, 0);\n    var yChar = makeTextPlane(\"Y\", \"green\", size / 10);\n    yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);\n    var axisZ = BABYLON.Mesh.CreateLines(\"axisZ\", [\n        new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3( -0.05 * size,0, size * 0.95),\n        new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0.05 * size, 0, size * 0.95)\n    ], scene);\n    axisZ.color = new BABYLON.Color3(0, 0, 1);\n    var zChar = makeTextPlane(\"Z\", \"blue\", size / 10);\n    zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);\n\n    axisX.position.addInPlaceFromFloats(0,offsetY,0);\n    axisY.position.addInPlaceFromFloats(0,offsetY,0);\n    axisZ.position.addInPlaceFromFloats(0,offsetY,0);\n};\n\n\n\n/*******************************Local Axes****************************/\n\n/**\n * Generates a mesh to represent local axes of a parent object \n * @param {*} size \n * @param {*} scene \n * @returns the mesh that represents the local origin of the axes\n */\nexport function showLocalAxes(size,scene) {\n    var pilot_local_axisX = BABYLON.Mesh.CreateLines(\"pilot_local_axisX\", [\n        new BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),\n        new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)\n    ], scene);\n    pilot_local_axisX.color = new BABYLON.Color3(1, 0, 0);\n\n    var pilot_local_axisY = BABYLON.Mesh.CreateLines(\"pilot_local_axisY\", [\n        new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),\n        new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)\n    ], scene);\n    pilot_local_axisY.color = new BABYLON.Color3(0, 1, 0);\n\n    var pilot_local_axisZ = BABYLON.Mesh.CreateLines(\"pilot_local_axisZ\", [\n        new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, -0.05 * size, size * 0.95),\n        new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, 0.05 * size, size * 0.95)\n    ], scene);\n    pilot_local_axisZ.color = new BABYLON.Color3(0, 0, 1);\n\n    var local_origin = BABYLON.MeshBuilder.CreateBox(\"local_origin\", { size: 1 }, scene);\n    local_origin.isVisible = false;\n\n    pilot_local_axisX.parent = local_origin;\n    pilot_local_axisY.parent = local_origin;\n    pilot_local_axisZ.parent = local_origin;\n\n    return local_origin;\n\n}","import * as BABYLON from 'babylonjs'\r\nimport * as MATERIALS from 'babylonjs-materials'\r\n\r\n/**\r\n * Creates a default playground with collisions\r\n * @param {Number} playground_width the width of the playground (x axis dimension)\r\n * @param {Number} playground_depth the depth of the playground (z axis dimension)\r\n * @param {Number} walls_width the thickness of the walls\r\n * @param {Number} walls_height the height of the walls\r\n * @param {BABYLON.Scene} scene \r\n * @returns the generated playground\r\n */\r\nexport function PlayGround({playground_width=50,playground_depth=50,walls_width=5,walls_height=10}={},scene) {\r\n\r\n    var ground =  BABYLON.MeshBuilder.CreateGround(\"ground\", { width: playground_width, height: playground_depth, subdivisionsX: 50, subdivisionsY: 50 },scene)\r\n\r\n    var wallF =  BABYLON.MeshBuilder.CreateBox(\"wallF\", { width: playground_width, height: walls_height, depth: walls_width },scene)\r\n    wallF.position.set(0, walls_height/2, playground_depth/2+walls_width/2)\r\n\r\n    var wallB =  BABYLON.MeshBuilder.CreateBox(\"wallB\", { width: playground_width, height: walls_height, depth: walls_width },scene)\r\n    wallB.position.set(0, walls_height/2, -playground_depth/2-walls_width/2)\r\n\r\n    var wallL = BABYLON.MeshBuilder.CreateBox(\"wallL\", { width: walls_width, height: walls_height, depth: playground_depth },scene)\r\n    wallL.position.set(-playground_width/2-walls_width/2, walls_height/2, 0)\r\n\r\n    var wallR = BABYLON.MeshBuilder.CreateBox(\"wallR\", { width: walls_width, height: walls_height, depth: playground_depth },scene)\r\n    wallR.position.set(playground_width/2+walls_width/2, walls_height/2 ,0)\r\n\r\n    wallF.visibility=0.2;\r\n    wallB.visibility=0.2;\r\n    wallL.visibility=0.2;\r\n    wallR.visibility=0.2;\r\n\r\n    ground.checkCollisions=true;\r\n    wallF.checkCollisions=true;\r\n    wallB.checkCollisions=true;\r\n    wallL.checkCollisions=true;\r\n    wallR.checkCollisions=true;\r\n\r\n    ground.addChild(wallF);\r\n    ground.addChild(wallB);\r\n    ground.addChild(wallL);\r\n    ground.addChild(wallR);\r\n\r\n    ground.position = new BABYLON.Vector3(0,0,0);\r\n    \r\n  \r\n    var gridground=ground.clone(\"gridground\");\r\n    gridground.position.y= ground.position.y+0.001;\r\n    var grid_ground_material = new MATERIALS.GridMaterial(\"groundmaterial\", scene)\r\n    grid_ground_material.majorUnitFrequency = 5;\r\n    grid_ground_material.minorUnitVisibility = 0.45;\r\n    grid_ground_material.gridRatio = 1;\r\n    grid_ground_material.backFaceCulling = false;\r\n    grid_ground_material.mainColor = new BABYLON.Color3(0, 0, 1);\r\n    grid_ground_material.lineColor = new BABYLON.Color3(1, 0, 0);\r\n    grid_ground_material.opacity = 0.98;\r\n  \r\n    gridground.material = grid_ground_material;\r\n\r\n    return {ground, wallF, wallB, wallL, wallR};\r\n\r\n}","import * as BABYLON from \"babylonjs\";\r\nimport * as GUI from \"babylonjs-gui\";\r\n\r\n/**\r\n   * Module to start XR functionalities (with auto XR mode detection).\r\n   * @param {BABYLON.Mesh} ground the instanced babylon js ground.\r\n   * @param {BABYLON.Mesh} skybox the instanced babylon js skybox.\r\n   * @param {[BABYLON.mesh]} mesheswithShadows array of meshes to simulate real time shadows.\r\n   * @param {BABYLON.Scene} scene the instanced babylon js scene.\r\n   * @returns the promised XR default experience instance.\r\n   */\r\nexport async function XR_Experience(ground, skybox, mesheswithShadows, scene) {\r\n\r\n\r\n    let inmersive_state = \"inline\";\r\n    let reference_floor = \"local-floor\"\r\n\r\n    let avaliableVR = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync(\"immersive-vr\");\r\n    let avaliableAR = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync(\"immersive-ar\");\r\n\r\n\r\n    console.log(\"AR mode avaliable: \" + avaliableAR);\r\n    console.log(\"VR mode avaliable: \" + avaliableVR);\r\n\r\n    if (avaliableVR) {\r\n\r\n        inmersive_state = \"immersive-vr\";\r\n\r\n        if (avaliableAR) {\r\n\r\n            inmersive_state = \"immersive-ar\";\r\n\r\n        }\r\n    }\r\n\r\n\r\n    const xr = scene.createDefaultXRExperienceAsync({\r\n        disableDefaultUI: true,\r\n        disableNearInteraction: true,\r\n        disablePointerSelection: false,\r\n        disableTeleportation: true,\r\n\r\n        optionalFeatures: true,\r\n\r\n        floorMeshes: [ground],\r\n\r\n        uiOptions: {\r\n            sessionMode: inmersive_state,\r\n            referenceSpaceType: reference_floor\r\n\r\n        },\r\n\r\n        inputOptions: {\r\n            doNotLoadControllerMeshes: false,\r\n\r\n        }\r\n\r\n\r\n    });\r\n\r\n\r\n    return xr.then((xrExperience) => {\r\n\r\n        var advancedTextureFullScreen = GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\", true, scene);\r\n\r\n\r\n\r\n        //HitTest(xrExperience,scene);\r\n        //AnchorSystem(xrExperience,advancedTextureFullScreen,scene);\r\n        LightEstimation(xrExperience,mesheswithShadows);\r\n\r\n        //basicAnchorSystem(xrExperience, advancedTextureFullScreen, scene);\r\n\r\n        xrExperience.input.xrCamera.setTransformationFromNonVRCamera(scene.activeCamera, true);\r\n        xrExperience.baseExperience.camera.setTransformationFromNonVRCamera(scene.activeCamera, true);\r\n\r\n\r\n\r\n        xrExperience.baseExperience.onStateChangedObservable.add((XRstate) => {\r\n\r\n            if (avaliableVR) {\r\n\r\n\r\n\r\n                switch (XRstate) {\r\n                    case BABYLON.WebXRState.IN_XR:\r\n                        // XR is initialized and already submitted one frame\r\n                        break\r\n                    case BABYLON.WebXRState.ENTERING_XR:\r\n                        // xr is being initialized, enter XR request was made\r\n\r\n                        break\r\n                    case BABYLON.WebXRState.EXITING_XR:\r\n                        // xr exit request was made. not yet done.\r\n                        break\r\n                    case BABYLON.WebXRState.NOT_IN_XR:\r\n                        // self explanatory - either out or not yet in XR\r\n                        break\r\n                }\r\n\r\n            }\r\n\r\n\r\n            if (avaliableAR) {\r\n\r\n                //xrExperience.baseExperience.camera.position = new BABYLON.Vector3(0,0,0);\r\n                //xrExperience.baseExperience.camera.setTarget(new BABYLON.Vector3(0,0,0));\r\n\r\n                //xrExperience.input.xrCamera.position = new BABYLON.Vector3(0, .01, -5);\r\n                //xrExperience.input.xrCamera.setTarget(new BABYLON.Vector3(0, 0, 0));\r\n\r\n                switch (XRstate) {\r\n                    case BABYLON.WebXRState.IN_XR:\r\n                        // XR is initialized and already submitted one frame\r\n                        break\r\n                    case BABYLON.WebXRState.ENTERING_XR:\r\n                        // xr is being initialized, enter XR request was made\r\n                        if (ground && mesheswithShadows.length > 1) {\r\n                            ground.visibility = 0;\r\n                        }\r\n                        if (skybox) {\r\n                            skybox.isVisible = false;\r\n                        }\r\n                        break\r\n                    case BABYLON.WebXRState.EXITING_XR:\r\n                        // xr exit request was made. not yet done.\r\n                        break\r\n                    case BABYLON.WebXRState.NOT_IN_XR:\r\n                        // self explanatory - either out or not yet in XR\r\n                        if (ground) {\r\n                            ground.visibility = 1;\r\n                        }\r\n                        if (skybox) {\r\n                            skybox.isVisible = true;\r\n                        }\r\n                        break\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n        });\r\n\r\n\r\n\r\n        var button1 = GUI.Button.CreateSimpleButton(\"but1\", \"A modo XR\");\r\n        button1.width = \"150px\"\r\n        button1.height = \"40px\";\r\n        button1.color = \"white\";\r\n        button1.cornerRadius = 20;\r\n        button1.background = \"green\";\r\n        button1.fontSize = \"20px\"\r\n        button1.horizontalAlignment = GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n        button1.verticalAlignment = GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n        button1.topInPixels = -5;\r\n        button1.leftInPixels = -5;\r\n\r\n\r\n        button1.onPointerUpObservable.add(function () {\r\n\r\n            if (xrExperience.baseExperience.state === BABYLON.WebXRState.NOT_IN_XR) {\r\n\r\n                xrExperience.baseExperience.enterXRAsync(inmersive_state, reference_floor);\r\n\r\n            } else if (xrExperience.baseExperience.state === BABYLON.WebXRState.IN_XR) {\r\n\r\n                xrExperience.baseExperience.exitXRAsync();\r\n            }\r\n\r\n\r\n        });\r\n        advancedTextureFullScreen.addControl(button1);\r\n\r\n\r\n        // GUI\r\n        var meshGUI = BABYLON.MeshBuilder.CreatePlane(\"plane\", {\r\n            width: .2 * 1.8,\r\n            height: .2,\r\n            sideOrientation: BABYLON.Mesh.DOUBLESIDE\r\n        }, scene);\r\n\r\n        meshGUI.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;\r\n        var advancedTexture = GUI.AdvancedDynamicTexture.CreateForMesh(meshGUI);\r\n\r\n        var container = new GUI.Rectangle(\"container\");\r\n        container.width = 1;\r\n        container.height = 1;\r\n        container.thickness = 0;\r\n        container.background = \"white\";\r\n        container.alpha = 0.05;\r\n        container.zIndex = -1;\r\n\r\n        advancedTexture.addControl(container);\r\n        advancedTexture.scaleTo(300, 150);\r\n\r\n        var button1 = GUI.Button.CreateSimpleButton(\"but1\", \"Salir modo XR\");\r\n        //button1.width = \"400px\";\r\n        //button1.height = \"100px\";\r\n        button1.color = \"white\";\r\n        button1.fontSize = 28;\r\n        button1.background = \"green\";\r\n        button1.onPointerUpObservable.add(function () {\r\n\r\n            if (xrExperience.baseExperience.state === BABYLON.WebXRState.NOT_IN_XR) {\r\n\r\n                xrExperience.baseExperience.enterXRAsync(inmersive_state, reference_floor);\r\n\r\n            } else if (xrExperience.baseExperience.state === BABYLON.WebXRState.IN_XR) {\r\n\r\n                xrExperience.baseExperience.exitXRAsync();\r\n            }\r\n\r\n        });\r\n        advancedTexture.addControl(button1);\r\n\r\n        meshGUI.position.addInPlaceFromFloats(0, 2, 0);\r\n\r\n\r\n        console.log(\"Se ha cargado funciones XR satisfactoriamente.\");\r\n        return xrExperience;\r\n    })\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n/**\r\n * \r\n * @param {BABYLON.WebXRDefaultExperience} xrExperience \r\n * @param {BABYLON.Scene} scene \r\n */\r\nfunction HitTest(xrExperience, scene) {\r\n\r\n    const xr_FeaturesManager = xrExperience.baseExperience.featuresManager;\r\n\r\n    const xr_HitTest = xr_FeaturesManager.enableFeature(BABYLON.WebXRHitTest, \"latest\");\r\n\r\n    const marker = BABYLON.MeshBuilder.CreateTorus('marker', { diameter: 0.15, thickness: 0.05 }, scene);\r\n    marker.isVisible = false;\r\n    marker.rotationQuaternion = new BABYLON.Quaternion();\r\n\r\n    var hitTest = null;\r\n\r\n    xr_HitTest.onHitTestResultObservable.add((results) => {\r\n        if (results.length) {\r\n            marker.isVisible = true;\r\n            hitTest = results[0];\r\n            hitTest.transformationMatrix.decompose(marker.scaling, marker.rotationQuaternion, marker.position);\r\n        } else {\r\n            marker.isVisible = false;\r\n        }\r\n    });\r\n\r\n\r\n}\r\n\r\n/**\r\n * \r\n * @param {BABYLON.WebXRDefaultExperience} xrExperience \r\n * @param {GUI.AdvancedDynamicTexture} advancedTextureFullScreen \r\n * @param {BABYLON.Scene} scene \r\n */\r\nfunction AnchorSystem(xrExperience, advancedTextureFullScreen, scene) {\r\n\r\n    const { featuresManager } = xrExperience.baseExperience;\r\n\r\n    featuresManager.enableFeature(BABYLON.WebXRBackgroundRemover);\r\n\r\n    // step 1 - enable hit test and anchor system from the features manager. \r\n\r\n    const hitTest = featuresManager.enableFeature(BABYLON.WebXRHitTest, 'latest');\r\n\r\n    const anchorSystem = featuresManager.enableFeature(BABYLON.WebXRAnchorSystem, 'latest');\r\n\r\n    // Step 2 - create a dot (sphere) that will be used to show the hit test result\r\n\r\n    const dot = BABYLON.SphereBuilder.CreateSphere('dot', {\r\n        diameter: 0.05\r\n    }, scene);\r\n    dot.rotationQuaternion = new BABYLON.Quaternion();\r\n\r\n    dot.material = new BABYLON.StandardMaterial('dot', scene);\r\n    dot.material.emissiveColor = BABYLON.Color3.Red();\r\n\r\n    dot.isVisible = false;\r\n\r\n    let lastHitTest = null;\r\n\r\n    const pairs = []; //measurement pair array\r\n    let currentPair = null; //current measurement pair\r\n\r\n    let anchorsAvailable = false;\r\n\r\n    // Step3 - listen to the hit test results and place the dot accordingly.\r\n\r\n    hitTest.onHitTestResultObservable.add((results) => {\r\n        if (results.length) {\r\n            dot.isVisible = true;\r\n            results[0].transformationMatrix.decompose(dot.scaling, dot.rotationQuaternion, dot.position);\r\n            lastHitTest = results[0];\r\n            if (currentPair) {\r\n                if (currentPair.line) {\r\n                    currentPair.line.dispose();\r\n                }\r\n                currentPair.line = BABYLON.MeshBuilder.CreateLines(\"lines\", {\r\n                    points: [\r\n                        currentPair.startDot.position,\r\n                        dot.position\r\n                    ]\r\n                }, scene);\r\n                const dist = BABYLON.Vector3.Distance(currentPair.startDot.position,\r\n                    dot.position);\r\n                currentPair.text.text = Math.round(dist * 100) / 100 + 'm';\r\n            }\r\n        } else {\r\n            lastHitTest = null;\r\n            dot.isVisible = false;\r\n        }\r\n    });\r\n\r\n    const processClick = () => {\r\n        const newDot = dot.clone('newDot');\r\n        if (!currentPair) {\r\n            const label = new GUI.Rectangle(\"label\");\r\n            label.background = \"black\"\r\n            label.height = \"60px\";\r\n            label.alpha = 0.5;\r\n            label.width = \"200px\";\r\n            label.cornerRadius = 20;\r\n            label.thickness = 1;\r\n            label.zIndex = 5;\r\n            advancedTextureFullScreen.addControl(label);\r\n\r\n            const text = new GUI.TextBlock();\r\n            text.color = \"white\";\r\n            text.fontSize = \"36px\"\r\n            label.addControl(text);\r\n            currentPair = {\r\n                startDot: newDot,\r\n                label,\r\n                text\r\n            }\r\n        } else {\r\n            currentPair.label.linkWithMesh(newDot);\r\n            currentPair.endDot = newDot;\r\n            pairs.push(currentPair);\r\n            currentPair = null;\r\n        }\r\n        return newDot;\r\n    }\r\n\r\n    anchorSystem.onAnchorAddedObservable.add((anchor) => {\r\n        anchor.attachedNode = processClick();\r\n    });\r\n\r\n    scene.onPointerObservable.add(async (eventData) => {\r\n        if (lastHitTest) {\r\n            if (lastHitTest.xrHitResult.createAnchor) {\r\n                const anchor = await anchorSystem.addAnchorPointUsingHitTestResultAsync(lastHitTest);\r\n            } else {\r\n                processClick();\r\n            }\r\n        }\r\n    }, BABYLON.PointerEventTypes.POINTERDOWN);\r\n\r\n    //update lines on each frame, as the anchor points can constantly change position\r\n    xrExperience.baseExperience.sessionManager.onXRFrameObservable.add(() => {\r\n        pairs.forEach(pair => {\r\n            pair.line.dispose();\r\n            pair.line = BABYLON.MeshBuilder.CreateLines(\"lines\", {\r\n                points: [\r\n                    pair.startDot.position,\r\n                    pair.endDot.position,\r\n                ]\r\n            }, scene);\r\n        })\r\n    })\r\n}\r\n\r\n/**\r\n * \r\n * @param {BABYLON.WebXRDefaultExperience} xrExperience \r\n * @param {GUI.AdvancedDynamicTexture} advancedTextureFullScreen \r\n * @param {BABYLON.Scene} scene \r\n */\r\nfunction basicAnchorSystem(xrExperience, advancedTextureFullScreen, scene) {\r\n\r\n    const { featuresManager } = xrExperience.baseExperience;\r\n\r\n    featuresManager.enableFeature(BABYLON.WebXRBackgroundRemover);\r\n\r\n    // step 1 - enable hit test and anchor system from the features manager. \r\n\r\n    const hitTest = featuresManager.enableFeature(BABYLON.WebXRHitTest, 'latest');\r\n\r\n    const anchorSystem = featuresManager.enableFeature(BABYLON.WebXRAnchorSystem, 'latest');\r\n\r\n    // Step 2 - create a dot (sphere) that will be used to show the hit test result\r\n\r\n    const dot = BABYLON.SphereBuilder.CreateSphere('dot', {\r\n        diameter: 0.05\r\n    }, scene);\r\n    dot.rotationQuaternion = new BABYLON.Quaternion();\r\n\r\n    dot.material = new BABYLON.StandardMaterial('dot', scene);\r\n    dot.material.emissiveColor = BABYLON.Color3.Red();\r\n\r\n    dot.isVisible = false;\r\n\r\n    let lastHitTest = null;\r\n\r\n    const pairs = []; //measurement pair array\r\n    let currentPair = null; //current measurement pair\r\n\r\n    // Step 3 - listen to the hit test results and place the dot accordingly.\r\n\r\n    hitTest.onHitTestResultObservable.add((results) => {\r\n        //if we have a hit test result\r\n        if (results.length) {\r\n            //set the dot position to the hit test result\r\n            dot.isVisible = true;\r\n            results[0].transformationMatrix.decompose(dot.scaling, dot.rotationQuaternion, dot.position);\r\n            lastHitTest = results[0];\r\n\r\n        } else {\r\n            lastHitTest = null;\r\n            dot.isVisible = false;\r\n        }\r\n    });\r\n\r\n    // process to create pairs of dots\r\n    const processClick = () => {\r\n        const newDot = dot.clone('newDot');\r\n        \r\n            const label = new GUI.Rectangle(\"label\");\r\n            label.background = \"black\"\r\n            label.height = \"60px\";\r\n            label.alpha = 0.5;\r\n            label.width = \"200px\";\r\n            label.cornerRadius = 20;\r\n            label.thickness = 1;\r\n            label.zIndex = 5;\r\n            advancedTextureFullScreen.addControl(label);\r\n\r\n            const text = new GUI.TextBlock(\"testlabel\", \"ancla\");\r\n            text.color = \"white\";\r\n            text.fontSize = \"36px\"\r\n            label.addControl(text);\r\n\r\n            label.linkWithMesh(newDot);\r\n\r\n            return newDot;\r\n        } \r\n       \r\n\r\n    // Step 4 - listen to the pointer down event to create an anchor\r\n    scene.onPointerObservable.add(async (eventData) => {\r\n        if (lastHitTest) {\r\n            if (lastHitTest.xrHitResult.createAnchor) {\r\n                const anchor = await anchorSystem.addAnchorPointUsingHitTestResultAsync(lastHitTest);\r\n            } else {\r\n                processClick();\r\n            }\r\n        }\r\n    }, BABYLON.PointerEventTypes.POINTERDOWN);\r\n\r\n    anchorSystem.onAnchorAddedObservable.add((anchor) => {\r\n        anchor.attachedNode = processClick();\r\n    });\r\n\r\n\r\n}\r\n\r\n/**\r\n * \r\n * @param {BABYLON.WebXRDefaultExperience} xrExperience \r\n * @param {[BABYLON.Scene]} mesheswithShadows \r\n */\r\nfunction LightEstimation(xrExperience, mesheswithShadows) {\r\n\r\n\r\n    const lightEstimation = xrExperience.baseExperience.featuresManager.enableFeature(BABYLON.WebXRFeatureName.LIGHT_ESTIMATION, 'latest', {\r\n        setSceneEnvironmentTexture: true,\r\n        // cubeMapPollInterval: 1000,\r\n        createDirectionalLightSource: true,\r\n        // reflectionFormat: 'srgba8',\r\n        // disableCubeMapReflection: true\r\n    });\r\n    const shadowGenerator = new BABYLON.ShadowGenerator(512, lightEstimation.directionalLight)\r\n    shadowGenerator.useBlurExponentialShadowMap = true;\r\n    shadowGenerator.blurScale = 2;\r\n    shadowGenerator.setDarkness(0.1);\r\n\r\n    mesheswithShadows.forEach((mesh) => {\r\n        shadowGenerator.getShadowMap().renderList.push(mesh);\r\n    })\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","\r\nimport * as BABYLON from \"babylonjs\";\r\n\r\n\r\nexport function GizmoInterface(scene) {\r\n\r\n\r\n    var attachedMesh = null;\r\n    var attachedMesh_mass = 0;\r\n    var holding = false;\r\n\r\n    const gizmoManager = new BABYLON.GizmoManager(scene, 1);\r\n\r\n\r\n    gizmoManager.scaleGizmoEnabled = false;\r\n    gizmoManager.positionGizmoEnabled = false;\r\n    gizmoManager.rotationGizmoEnabled = false;\r\n    gizmoManager.boundingBoxGizmoEnabled = true;\r\n\r\n    gizmoManager.gizmos.boundingBoxGizmo.fixedDragMeshBoundsSize=true;\r\n    gizmoManager.gizmos.boundingBoxGizmo.ignoreChildren=true;\r\n    \r\n\r\n    gizmoManager.usePointerToAttachGizmos = false;\r\n    gizmoManager.clearGizmoOnEmptyPointerEvent = true;\r\n\r\n\r\n    scene.onPointerObservable.add((pointerInfo) => {\r\n       \r\n        switch (pointerInfo.type) {\r\n            case BABYLON.PointerEventTypes.POINTERDOWN:\r\n                if (!holding && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedMesh.XRpickable) {\r\n                  \r\n                    holding = true;\r\n                    attachedMesh = pointerInfo.pickInfo.pickedMesh;\r\n                    gizmoManager.attachToMesh(attachedMesh);\r\n                    \r\n                    if (attachedMesh.physicsImpostor) {\r\n                       \r\n                      \r\n                        attachedMesh_mass = attachedMesh.physicsImpostor.mass;\r\n                        attachedMesh.physicsImpostor.setMass(0);\r\n                       \r\n\r\n                    }\r\n                }\r\n\r\n                if (!holding && pointerInfo.pickInfo.pickedMesh && !pointerInfo.pickInfo.pickedMesh.XRpickable) {\r\n                    attachedMesh = null;\r\n                    gizmoManager.attachToMesh(null);\r\n                }\r\n\r\n                break;\r\n            case BABYLON.PointerEventTypes.POINTERUP:\r\n                if (holding && attachedMesh) {\r\n                    holding = false;\r\n                    if (attachedMesh.physicsImpostor) {\r\n                        attachedMesh.physicsImpostor.setMass(attachedMesh_mass);\r\n                    }\r\n\r\n                }\r\n\r\n            default:\r\n                break;\r\n        }\r\n\r\n    })\r\n\r\n\r\n    scene.onKeyboardObservable.add((keydata) => {\r\n\r\n        //keydata.event.key\r\n        switch (keydata.type) {\r\n            case BABYLON.KeyboardEventTypes.KEYDOWN:\r\n                //console.log(\"key pressed\")\r\n                switch (keydata.event.key) {\r\n\r\n                    case \"1\":\r\n                        gizmoManager.scaleGizmoEnabled = !gizmoManager.scaleGizmoEnabled;                            \r\n                        gizmoManager.positionGizmoEnabled = false;\r\n                        gizmoManager.rotationGizmoEnabled = false;\r\n                        gizmoManager.boundingBoxGizmoEnabled = false;\r\n\r\n                        break;\r\n                    case \"2\":\r\n                        gizmoManager.positionGizmoEnabled = !gizmoManager.positionGizmoEnabled;\r\n                        gizmoManager.scaleGizmoEnabled = false;\r\n                        gizmoManager.rotationGizmoEnabled = false;\r\n                        gizmoManager.boundingBoxGizmoEnabled = false;\r\n                        break;\r\n                    case \"3\":\r\n                        gizmoManager.rotationGizmoEnabled = !gizmoManager.rotationGizmoEnabled;\r\n                        gizmoManager.scaleGizmoEnabled = false;\r\n                        gizmoManager.positionGizmoEnabled = false;\r\n                        gizmoManager.boundingBoxGizmoEnabled = false;\r\n                        break;\r\n                    case \"4\":\r\n                        gizmoManager.boundingBoxGizmoEnabled = !gizmoManager.boundingBoxGizmoEnabled;\r\n                        gizmoManager.scaleGizmoEnabled = false;\r\n                        gizmoManager.positionGizmoEnabled = false;\r\n                        gizmoManager.rotationGizmoEnabled = false;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n        }\r\n\r\n    })\r\n\r\n}","\r\nimport React from \"react\";\r\nimport * as BABYLON from \"babylonjs\";\r\nimport * as MATERIALS from \"babylonjs-materials\"\r\nimport SceneComponent from \"../Babylon_components/SceneComponent\";\r\n// import SceneComponent from 'babylonjs-hook'; // if you install 'babylonjs-hook' NPM.\r\n\r\nimport * as Cameras_Module from \"../Modules/Cameras_Module\"\r\nimport * as Lights_Module from \"../Modules/Lights_Module\"\r\nimport * as Materials_Module from \"../Modules/Materials_Module\";\r\n\r\nimport * as Babylon_Components from \"../Babylon_components\"\r\n\r\nimport * as XR_Module from \"../Modules/XR_Module\"\r\nimport * as Gizmo from \"../Modules/GizmoInterface\"\r\n\r\nimport ammo from \"ammo.js\"\r\n\r\n\r\nconst onSceneReady = async (e = { engine: new BABYLON.Engine, scene: new BABYLON.Scene, canvas: new HTMLCanvasElement }) => {\r\n\r\n  const { canvas, scene, engine } = e;\r\n\r\n  Cameras_Module.FreeCameraDefault(canvas, scene);\r\n\r\n  Lights_Module.HemisphericLight(scene);\r\n\r\n  // Sky material\r\n  var skyboxMaterial = new MATERIALS.SkyMaterial(\"skyMaterial\", scene);\r\n  skyboxMaterial.backFaceCulling = false;\r\n\r\n  // Sky mesh (box)\r\n  var skybox = BABYLON.Mesh.CreateBox(\"skyBox\", 1000.0, scene);\r\n  skybox.material = skyboxMaterial;\r\n\r\n  skybox.material.inclination = -0.35;\r\n\r\n  var playground = Babylon_Components.PlayGround();\r\n\r\n  scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.AmmoJSPlugin(true, await ammo()));\r\n\r\n\r\n  var ground_impostor = new BABYLON.PhysicsImpostor(playground.ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.9 }, scene);\r\n  playground.ground.physicsImpostor = ground_impostor;\r\n\r\n  var sphere = BABYLON.MeshBuilder.CreateSphere(\"sphere\", { diameter: 3 }, scene);\r\n  sphere.position.y = 4;\r\n  var sphere_impostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.9 }, scene);\r\n  sphere.physicsImpostor = sphere_impostor;\r\n\r\n  var box_material = Materials_Module.MaterialRandom();\r\n  var box = BABYLON.MeshBuilder.CreateBox(\"box\", { size: 2 }, scene);\r\n  box.material = box_material;\r\n\r\n  box.position = new BABYLON.Vector3(1, 1, 1);\r\n  var box_impostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, restitution: 0.9 }, scene);\r\n  box.physicsImpostor = box_impostor;\r\n\r\n  Babylon_Components.showWorldAxis(10, scene);\r\n  var localAxe1 = Babylon_Components.showLocalAxes(3, scene);\r\n\r\n  localAxe1.parent = box;\r\n\r\n  scene.onBeforeRenderObservable.add(() => {\r\n    if (box !== undefined) {\r\n      const deltaTimeInMillis = scene.getEngine().getDeltaTime();\r\n\r\n      const rpm = 30\r\n      //box.rotation.y += (rpm / 60) * Math.PI * 2 * (deltaTimeInMillis / 1000);\r\n      box.rotate(BABYLON.Axis.Y, (rpm / 60) * Math.PI * 2 * (deltaTimeInMillis / 1000), scene);\r\n    }\r\n\r\n  });\r\n\r\n  var mesheswithShadows = [];\r\n  mesheswithShadows.push(box, sphere);\r\n\r\n\r\n  const XR = XR_Module.XR_Experience(playground.ground, skybox, mesheswithShadows, scene);\r\n  Gizmo.GizmoInterface(scene);\r\n  box.XRpickable = true;\r\n  sphere.XRpickable = true;\r\n\r\n  var meshes = [];\r\n  meshes.push(box, sphere, skybox);\r\n\r\n  /**\r\n   * \r\n   * @param {BABYLON.Mesh} mesh mesh to add reflective texture.\r\n   * @param {[BABYLON.Mesh]} otherMeshs array of meshes to reflect.\r\n   * @param {BABYLON.Scene} scene a constructed babylon js scene.\r\n   */\r\n  function CreateReflectionTexture(mesh, otherMeshs, scene) {\r\n\r\n    // Reflection probe\r\n    var rp = new BABYLON.ReflectionProbe('ref', 512, scene);\r\n    otherMeshs.forEach(element => {\r\n\r\n      rp.renderList.push(element);\r\n    });\r\n\r\n    // PBR\r\n    var pbr = new BABYLON.PBRMaterial('pbr', scene);\r\n    pbr.reflectionTexture = rp.cubeTexture;\r\n    mesh.material = pbr;\r\n\r\n    rp.attachToMesh(mesh);\r\n\r\n  }\r\n  //CreateReflectionTexture(box, meshes, scene);\r\n  //CreateReflectionTexture(sphere, meshes, scene);\r\n\r\n};\r\n\r\n\r\nfunction Scene() {\r\n  return (\r\n    <SceneComponent antialias onSceneReady={onSceneReady} id=\"SceneCanvas\" />\r\n  );\r\n}\r\n\r\nexport default Scene;\r\n","\r\nimport React from \"react\";\r\nimport * as BABYLON from \"babylonjs\";\r\nimport * as MATERIALS from \"babylonjs-materials\"\r\nimport SceneComponent from \"../Babylon_components/SceneComponent\"; \r\n// import SceneComponent from 'babylonjs-hook'; // if you install 'babylonjs-hook' NPM.\r\n\r\n\r\nconst onSceneReady = (e) => {\r\n\r\n  const { canvas, scene, engine } = e;\r\n  // This creates and positions a free camera (non-mesh)\r\n  const camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 5, -10), scene);\r\n\r\n  // This targets the camera to scene origin\r\n  camera.setTarget(BABYLON.Vector3.Zero());\r\n\r\n  // This attaches the camera to the canvas\r\n  camera.attachControl(canvas, false);\r\n\r\n  // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\r\n  const light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n\r\n  // Default intensity is 1. Let's dim the light a small amount\r\n  light.intensity = 0.7;\r\n\r\n  //Display 3D axes\r\n  const axes3D = new BABYLON.AxesViewer(scene,2)\r\n\r\n  // Our built-in shapes examples.\r\n  var box = BABYLON.MeshBuilder.CreateBox(\"box\", { size: 2 }, scene);\r\n\r\n  var sphere = BABYLON.MeshBuilder.CreateSphere(\"sphere\",{diameterX:2,diameterY:2,diameterZ:2},scene);\r\n\r\n  var cone = BABYLON.MeshBuilder.CreateCylinder(\"cone\",{height:2,diameterTop:0,diameterBottom:2,tessellation:4},scene);\r\n\r\n  var plane = BABYLON.MeshBuilder.CreatePlane(\"plane\", {width: 5, height: 2}, scene);\r\n\r\n  var torus = BABYLON.MeshBuilder.CreateTorus(\"torus\", {thickness: 0.2,diameter:2}, scene);\r\n\r\n  // Our built-in 'ground' shape.\r\n  var ground = BABYLON.MeshBuilder.CreateGround(\"ground\", { width: 100, height: 100,subdivisions:100 }, scene);\r\n\r\n  // Move the position of each shape\r\n  box.position.x = 0;\r\n  box.position.y = 1;\r\n  box.position.z = 0;\r\n\r\n  sphere.setAbsolutePosition(new BABYLON.Vector3(-3,1,0));\r\n  var newSpherePosition = sphere.position.addInPlace(new BABYLON.Vector3(0,0,0));\r\n  console.log(newSpherePosition)\r\n\r\n  cone.setAbsolutePosition(new BABYLON.Vector3(3,1,0));\r\n\r\n  plane.setAbsolutePosition(new BABYLON.Vector3(0,3,2));\r\n\r\n  torus.setAbsolutePosition(new BABYLON.Vector3(-6,1,0));\r\n\r\n  /*\r\n  const axesBox = new BABYLON.AxesViewer(scene,1)\r\n  xesBox.xAxis.parent = box;\r\n  axesBox.yAxis.parent = box;\r\n  axesBox.zAxis.parent = box;\r\n\r\n  */\r\n\r\n\r\n  /*\r\n  var groundMaterial = new MATERIALS.GridMaterial(\"groundmaterial\", scene)\r\n\tgroundMaterial.majorUnitFrequency = 5;\r\n\tgroundMaterial.minorUnitVisibility = 0.45;\r\n\tgroundMaterial.gridRatio = 2;\r\n\tgroundMaterial.backFaceCulling = false;\r\n\tgroundMaterial.mainColor = new BABYLON.Color3(1, 1, 1);\r\n\tgroundMaterial.lineColor = new BABYLON.Color3(1.0, 1.0, 1.0);\r\n\tgroundMaterial.opacity = 0.98;\r\n\r\n  ground.material = groundMaterial;\r\n\r\n  */\r\n\r\n  /*\r\n\tvar skyMaterial = new MATERIALS.GridMaterial(\"skyMaterial\", scene);\r\n\tskyMaterial.majorUnitFrequency = 6;\r\n\tskyMaterial.minorUnitVisibility = 0.43;\r\n\tskyMaterial.gridRatio = 0.5;\r\n\tskyMaterial.mainColor = new BABYLON.Color3(0, 0.05, 0.2);\r\n\tskyMaterial.lineColor = new BABYLON.Color3(0, 1.0, 1.0);\t\r\n\tskyMaterial.backFaceCulling = false;\r\n\t\r\n\tvar skySphere = BABYLON.Mesh.CreateSphere(\"skySphere\", 30, 110, scene);\r\n\tskySphere.material = skyMaterial;\r\n\r\n  */\r\n\t\r\n\r\n  scene.onBeforeRenderObservable.add(() =>{\r\n    if (box !== undefined) {\r\n      const deltaTimeInMillis = scene.getEngine().getDeltaTime();\r\n  \r\n      const rpm = 30\r\n      box.rotation.y += (rpm / 60) * Math.PI * 2 * (deltaTimeInMillis / 1000); \r\n      //cone.rotation.y += (rpm / 60) * Math.PI * 2 * (deltaTimeInMillis / 1000);  \r\n      //sphere.rotation.y += (rpm / 60) * Math.PI * 2 * (deltaTimeInMillis / 1000);   \r\n    } \r\n\r\n  });\r\n\r\n};\r\n\r\n\r\nfunction Tema() {\r\n  return (\r\n      <SceneComponent antialias onSceneReady={onSceneReady} id=\"SceneCanvas\" />\r\n  );\r\n}\r\n\r\nexport default Tema;\r\n","import * as BABYLON from \"babylonjs\";\nimport SceneComponent from \"../Babylon_components/SceneComponent\";\nimport { showWorldAxis, showLocalAxes } from \"../Babylon_components/Axes\"\n\n\n\nconst onSceneReady = (e = { engine: new BABYLON.Engine, scene: new BABYLON.Scene, canvas: new HTMLCanvasElement }) => {\n\n  const { canvas, scene, engine } = e;\n  // This creates and positions a free camera (non-mesh)\n  //const camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 5, -10), scene);\n  const camera = new BABYLON.ArcRotateCamera(\"camera1\", 0, 0, 0, new BABYLON.Vector3(2, 3, 4), scene);\n\n  // This targets the camera to scene origin\n  //camera.setTarget(BABYLON.Vector3.Zero());\n  camera.setPosition(new BABYLON.Vector3(10, 3, -10))\n\n  // This attaches the camera to the canvas\n  camera.attachControl(canvas, false);\n\n  // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n  const light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\n\n  // Default intensity is 1. Let's dim the light a small amount\n  light.intensity = 0.7;\n\n\n  /************Start Pilot*********************************/\n\n  var body = BABYLON.MeshBuilder.CreateCylinder(\"body\", { height: 0.75, diameterTop: 0.2, diameterBottom: 0.5, tessellation: 6, subdivisions: 1 }, scene);\n  var arm = BABYLON.MeshBuilder.CreateBox(\"arm\", { height: 0.75, width: 0.3, depth: 0.1875 }, scene);\n  arm.position.x = 0.125;\n  var pilot = BABYLON.Mesh.MergeMeshes([body, arm], true);\n\n  /*Create world and local axes */\n\n  showWorldAxis(8, scene)\n\n  var localOrigin = showLocalAxes(2, scene);\n  localOrigin.parent = pilot;\n\n\n  /* Change pilot position */\n  pilot.position = new BABYLON.Vector3(2, 3, 4);\n\n  /* Change pilot rotation */\n  //pilot.rotation.x = Math.PI/2;  //number is a radian \n  pilot.rotation.x = Degrees_to_radians(0)\n\n  //pilot.rotation.y = Math.PI/2;  //number is a radian \n  pilot.rotation.y = Degrees_to_radians(0)\n\n  //pilot.rotation.z = Math.PI/2;  //number is a radian \n  pilot.rotation.z = Degrees_to_radians(0)\n\n\n  /*Examples using boxes  */\n\n  var faceColors = [];\n  faceColors[0] = BABYLON.Color3.Blue();\n  faceColors[1] = BABYLON.Color3.Red();\n  faceColors[2] = BABYLON.Color3.Green();\n  faceColors[3] = BABYLON.Color3.White();\n  faceColors[4] = BABYLON.Color3.Yellow();\n  faceColors[5] = BABYLON.Color3.Black();\n\n  var options = {\n    width: 0.7,\n    height: 0.7,\n    depth: 0.7,\n    faceColors: faceColors\n  };\n\n\n  var box1 = BABYLON.Mesh.CreateBox(\"Box1\", 1.0, scene);\n\n  var box2 = BABYLON.Mesh.CreateBox(\"Box2\", 1.0, scene);\n\n  var mainbox = BABYLON.MeshBuilder.CreateBox(\"mainbox\", options, scene, true)\n\n  var box4 = BABYLON.Mesh.CreateBox(\"Box4\", 1.0, scene);\n  var box5 = BABYLON.Mesh.CreateBox(\"Box5\", 1.0, scene);\n  var box6 = BABYLON.Mesh.CreateBox(\"Box6\", 1.0, scene);\n  var box7 = BABYLON.Mesh.CreateBox(\"Box7\", 1.0, scene);\n\n\n  //Adding local axes for main box\n  var localOriginBox = showLocalAxes(2, scene);\n  localOriginBox.parent = mainbox;\n\n  //Moving boxes on the x axis\n  box1.position.x = -4.0;\n  box2.position.x = -2.0;\n  mainbox.position.x = 0;\n  box4.position.x = 2;\n  box5.position.x = 4;\n  box6.position.x = 6;\n\n  //Rotate box around the x axis\n  box1.rotation.x = Math.PI / 3;\n\n  //Rotate box around the y axis\n  box2.rotation.y = Math.PI / 3;\n\n  //Scaling on the x axis\n  box4.scaling.x = 2;\n\n  //Scaling on the y axis\n  box5.scaling.y = 2;\n\n  //Scaling on the z axis\n  box6.scaling.z = 2;\n\n  //Moving box7 relatively to box1\n  box7.parent = box1;\n  box7.position.z = -2;\n\n  console.log(\"hola mundo\")\n\n  console.log(box7)\n\n  /**\n   * funcion para convertir grados a radianes\n   * @param {*} degrees \n   * @returns un mumero en radianes\n   */\n  function Degrees_to_radians(degrees) {\n\n    var result_radians = degrees * (Math.PI / 180)\n\n    return result_radians\n  }\n\n\n  var rot_x = Math.PI / 128;\n  var rot_y = 0;\n  var rot_z = 0;\n\n  var rot_count = 0; // for oscillation (rotation)\n  var rot_temp;\n\n  var a = 0; // for oscillation (translation)\n\n  scene.onBeforeRenderObservable.add(() => {\n\n    if (rot_count == 128) {\n      rot_count = 0;\n      rot_temp = rot_z;\n      rot_z = rot_y;\n      rot_y = rot_x;\n      rot_x = rot_temp;\n    }\n    mainbox.addRotation(rot_x, rot_y, rot_z); // for adding rotation\n    rot_count++;\n\n    a += 0.005;\n    var sign = Math.cos(a) / Math.abs(Math.cos(a)); //signoidal function for movement\n    //mainbox.locallyTranslate(new BABYLON.Vector3(0.02 * sign, 0, 0.02 * sign));\n\n  });\n\n  \n\n  engine.runRenderLoop(() => {\n    if (scene) {\n      scene.render();\n    }\n  });\n\n\n};\n\n\nfunction Scene() {\n  return (\n    <SceneComponent antialias onSceneReady={onSceneReady} id=\"SceneCanvas\" />\n  );\n}\n\nexport default Scene;\n","import * as BABYLON from \"babylonjs\";\nimport * as MATERIALS from \"babylonjs-materials\"\nimport SceneComponent from \"../Babylon_components/SceneComponent\";\nimport { showWorldAxis, showLocalAxes } from \"../Babylon_components/Axes\"\n\n\nconst onSceneReady = (e = { engine: new BABYLON.Engine, scene: new BABYLON.Scene, canvas: new HTMLCanvasElement }) => {\n\n  const { canvas, scene, engine } = e;\n  // This creates and positions a free camera (non-mesh)\n  const camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 5, -10), scene);\n  //const camera = new BABYLON.ArcRotateCamera(\"camera1\", 0, 0, 0, new BABYLON.Vector3(2, 3, 4), scene);\n\n  // This targets the camera to scene origin\n  camera.setTarget(BABYLON.Vector3.Zero());\n  //camera.setPosition(new BABYLON.Vector3(10, 3, -10))\n\n  // This attaches the camera to the canvas\n  camera.attachControl(canvas, false);\n\n  // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n  const light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\n\n  // Default intensity is 1. Let's dim the light a small amount\n  light.intensity = 0.7;\n\n  var ground = new BABYLON.MeshBuilder.CreateGround(\"ground\", { width: 100, height: 100 }, scene)\n\n  var groundMaterial = new MATERIALS.GridMaterial(\"groundmaterial\", scene)\n  groundMaterial.majorUnitFrequency = 5;\n  groundMaterial.minorUnitVisibility = 0.45;\n  groundMaterial.gridRatio = 1;\n  groundMaterial.backFaceCulling = false;\n  groundMaterial.mainColor = new BABYLON.Color3(1, 1, 1);\n  groundMaterial.lineColor = new BABYLON.Color3(1.0, 1.0, 1.0);\n  groundMaterial.opacity = 0.9;\n\n  ground.material = groundMaterial;\n\n\n\n  /************Start Pilot*********************************/\n\n  var body = BABYLON.MeshBuilder.CreateCylinder(\"body\", { height: 0.75, diameterTop: 0.2, diameterBottom: 0.5, tessellation: 6, subdivisions: 1 }, scene);\n  var arm = BABYLON.MeshBuilder.CreateBox(\"arm\", { height: 0.75, width: 0.3, depth: 0.1875 }, scene);\n  arm.position.x = 0.125;\n\n  var pilot_with_WORLD_translate = BABYLON.Mesh.MergeMeshes([body, arm], true);\n\n  var pilot_with_LOCAL_translate = pilot_with_WORLD_translate.createInstance(\"pilot local\");\n\n  /*Create world and local axes */\n\n\n  showWorldAxis(8, scene)\n\n  var localOrigin_1 = showLocalAxes(2, scene);\n  localOrigin_1.parent = pilot_with_WORLD_translate;\n  pilot_with_WORLD_translate.rotation.y = Degrees_to_radians(120);\n\n\n  var localOrigin_2 = showLocalAxes(2, scene);\n  localOrigin_2.parent = pilot_with_LOCAL_translate;\n  pilot_with_LOCAL_translate.rotation.y = Degrees_to_radians(120);\n\n\n  var direction_traslation_vector = new BABYLON.Vector3(0, 0, 4);\n  direction_traslation_vector.normalize();\n  var distance_per_render = 0.01;\n  var i = 0;\n\n\n  var unit_per_secs = 1\n  var distance_final = 10\n\n\n  scene.onBeforeRenderObservable.add(() => {\n\n    const deltaTimeInMillis = scene.getEngine().getDeltaTime();\n    const deltaTimeInsecs = (scene.getEngine().getDeltaTime()) / 1000;\n\n    //if (i++ < 500) pilot_with_WORLD_translate.translate(direction_traslation_vector, distance_per_render*deltaTimeInMillis, BABYLON.Space.WORLD); //eje Z azul del mundo\n    //if (i++ < 500) pilot_with_LOCAL_translate.translate(direction_traslation_vector, distance_per_render*deltaTimeInMillis, BABYLON.Space.LOCAL); //eje z azul del pilot\n\n    i = i + unit_per_secs * deltaTimeInsecs;\n    if (i <= distance_final) pilot_with_WORLD_translate.translate(direction_traslation_vector, unit_per_secs * deltaTimeInsecs, BABYLON.Space.WORLD);\n\n    ; //eje Z azul del mundo\n    if (i <= distance_final) pilot_with_LOCAL_translate.translate(direction_traslation_vector, unit_per_secs * deltaTimeInsecs, BABYLON.Space.LOCAL); //eje z azul del pilot\n\n\n  });\n\n\n\n  /*Examples using boxes  */\n\n  var faceColors = [];\n  faceColors[0] = BABYLON.Color3.Blue();\n  faceColors[1] = BABYLON.Color3.Red();\n  faceColors[2] = BABYLON.Color3.Green();\n  faceColors[3] = BABYLON.Color3.White();\n  faceColors[4] = BABYLON.Color3.Yellow();\n  faceColors[5] = BABYLON.Color3.Black();\n\n  var options = {\n    width: 0.7,\n    height: 0.7,\n    depth: 0.7,\n    faceColors: faceColors\n  };\n\n  var mainbox = BABYLON.MeshBuilder.CreateBox(\"mainbox\", options, scene, true);\n  //Adding local axes for main box\n  var localOriginBox = showLocalAxes(2, scene);\n  localOriginBox.parent = mainbox;\n\n\n  /**\n   * funcion para convertir grados a radianes\n   * @param {*} degrees \n   * @returns un mumero en radianes\n   */\n  function Degrees_to_radians(degrees) {\n\n    var result_radians = degrees * (Math.PI / 180)\n\n    return result_radians\n  }\n\n\n  var rot_x = Math.PI / 128;\n  var rot_y = 0;\n  var rot_z = 0;\n\n  var rot_count = 0; // for oscillation (rotation)\n  var rot_temp;\n\n  var a = 0; // for oscillation (translation)\n\n  scene.onBeforeRenderObservable.add(() => {\n\n    if (rot_count == 128) {\n      rot_count = 0;\n      rot_temp = rot_z;\n      rot_z = rot_y;\n      rot_y = rot_x;\n      rot_x = rot_temp;\n    }\n    mainbox.addRotation(rot_x, rot_y, rot_z); // for adding rotation\n    rot_count++;\n\n    a += 0.005;\n    var sign = Math.cos(a) / Math.abs(Math.cos(a)); //signoidal function for movement\n    //mainbox.locallyTranslate(new BABYLON.Vector3(0.02 * sign, 0, 0.02 * sign));\n\n  });\n\n\n\n  //Using Transformation Nodes for easing mesh trasformations.\n\n  //create sphere to indicate position of Center of Transformation\n  var node_sphere = BABYLON.MeshBuilder.CreateSphere(\"Sphere\", { diameter: 0.1 }, scene, true);\n  node_sphere.material = new BABYLON.StandardMaterial(\"mat\", scene);\n  node_sphere.material.diffuseColor = new BABYLON.Color3(1, 0, 1);\n\n  // create axes for frame of reference of Center of Transformation\n  var CoTAxis = showLocalAxes(2, scene);\n  var CoT_2Axis = showLocalAxes(2, scene);\n  var CoT_3Axis = showLocalAxes(1, scene);\n\n\n  //create a Center of Transformation\n  var CoT = new BABYLON.TransformNode(\"root\", scene);\n  var CoT_2 = new BABYLON.TransformNode(\"secondary\", scene);\n  var CoT_3 = new BABYLON.TransformNode(\"tertiary\");\n\n  //now parenting other elements\n  node_sphere.parent = CoT;\n  CoTAxis.parent = CoT;\n  CoT.rotation.y = Math.PI / 4;\n  CoT.position = new BABYLON.Vector3(5, 0, 5);\n\n  CoT_2Axis.parent = CoT_2;\n  CoT_2.parent = CoT;\n  CoT_2.position.z = 4;\n\n  CoT_3Axis.parent = CoT_3;\n  CoT_3.parent = CoT_2;\n  CoT_3.position.z = 2;\n\n\n  //create box \n  var faceColors = [];\n  faceColors[0] = BABYLON.Color3.Blue();\n  faceColors[1] = BABYLON.Color3.Red();\n  faceColors[2] = BABYLON.Color3.Green();\n  faceColors[3] = BABYLON.Color3.White();\n  faceColors[4] = BABYLON.Color3.Yellow();\n  faceColors[5] = BABYLON.Color3.Black();\n\n  var options = {\n    faceColors: faceColors\n  };\n\n\n  var rotating_box = BABYLON.MeshBuilder.CreateBox(\"Box\", options, scene, true);\n\n\n  var rotating_box_mini = BABYLON.MeshBuilder.CreateBox(\"minibox\", options, scene);\n  rotating_box_mini.scaling = new BABYLON.Vector3(0.3, 0.3, 0.3);\n\n\n  //Animation\n  var angle_CoT = 0;\n  var angle_CoT2 = 0;\n  var angle_CoT3 = 0;\n\n  var angle_box = 0;\n  var angle_mini_box = 0;\n\n\n  const Cot_angle_per_secs = Degrees_to_radians(15);\n  const Cot2_angle_per_secs = Degrees_to_radians(30);\n  const Cot3_angle_per_secs = Degrees_to_radians(0);\n\n  const rotating_box_angle_per_secs = Degrees_to_radians(360)\n  const mini_box_angle_per_secs = Degrees_to_radians(180);\n\n  //rotating_box.parent = CoT_2;\n  rotating_box.visibility=0.3\n\n\n  scene.onBeforeRenderObservable.add(() => {\n\n    var deltaTimeInsecs = (scene.getEngine().getDeltaTime()) / 1000;\n\n    CoT.rotation.y = angle_CoT;\n    CoT_2.rotation.y = angle_CoT2;\n    CoT_3.rotation.y = angle_CoT3;\n\n    rotating_box.position = CoT_2.absolutePosition;\n    rotating_box.rotation.y = angle_box;\n    rotating_box_mini.position = CoT_3.absolutePosition;\n    rotating_box_mini.rotation.y = angle_mini_box;\n\n\n    angle_CoT += Cot_angle_per_secs * deltaTimeInsecs;\n    angle_CoT2 += Cot2_angle_per_secs * deltaTimeInsecs;\n    angle_CoT3 += Cot3_angle_per_secs * deltaTimeInsecs;\n\n\n    angle_box += rotating_box_angle_per_secs * deltaTimeInsecs;\n    angle_mini_box += mini_box_angle_per_secs * deltaTimeInsecs;\n\n\n  })\n\n\n\n  //create two boxes that follow a path\n  var box_follower1 = BABYLON.MeshBuilder.CreateBox(\"box_follower1\", options, scene, true);\n  box_follower1.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);\n  var box_follower2 = box_follower1.clone(\"box_follower2\")\n\n  // Create array of points to create a circle path (using CreateLines)\n\n  var circle_points = [];\n  var n = 500; // number of points\n  var r = 10; //radius\n  for (var total = 0; total < n; total++) {\n    circle_points.push(new BABYLON.Vector3(\n      0 + r * Math.cos(total * Math.PI * 2 / n),\n      0,\n      r * Math.sin(total * Math.PI * 2 / n)\n    ));\n  }\n\n  circle_points.push(circle_points[0]); // push to close path\n  var circle = BABYLON.MeshBuilder.CreateLines(\"circle\", { points: circle_points }, scene);\n\n  box_follower1.parent = circle;\n\n  //create array of points to create a elliptical path (using CreateLines)\n\n  var a = 2.5; // Z width\n  var b = 5; // X width\n  var totalPoints = 400; //number of points\n  var ellipse_points = [];\n  var deltaTheta = Math.PI / totalPoints;\n\n  for (var theta = 0; theta < 2 * Math.PI; theta += deltaTheta) {\n    ellipse_points.push(new BABYLON.Vector3(b * Math.sin(theta), 0, a * Math.cos(theta)));\n  }\n\n  var ellipse = BABYLON.MeshBuilder.CreateLines(\"ellipse\", { points: ellipse_points }, scene);\n  ellipse.color = BABYLON.Color3.Red();\n  \n\n  box_follower2.parent = ellipse;\n\n  ellipse.position = new BABYLON.Vector3(15, 3, 10)\n\n  var box_follower1_movement = 0;\n  var box_follower2_movement = 0;\n\n  var box_follower_rotation = 0\n  var rotation_per_sec = Degrees_to_radians(180);\n\n  scene.onBeforeRenderObservable.add(() => {\n\n    var deltaTimeInsecs = (scene.getEngine().getDeltaTime()) / 1000;\n\n\n    box_follower1.position.x = circle_points[box_follower1_movement].x\n    box_follower1.position.z = circle_points[box_follower1_movement].z\n\n    box_follower1_movement = (box_follower1_movement + 1) % (circle_points.length - 1)\n\n  \n    box_follower2.position.x = ellipse_points[box_follower2_movement].x\n    box_follower2.position.z = ellipse_points[box_follower2_movement].z\n\n    box_follower2_movement = (box_follower2_movement + 1) % (ellipse_points.length - 1)\n\n\n    box_follower1.rotation.y = box_follower_rotation;\n    box_follower2.rotation.y = box_follower_rotation;\n    box_follower_rotation += rotation_per_sec * deltaTimeInsecs;\n\n\n  })\n\n\n  engine.runRenderLoop(() => {\n    if (scene) {\n      scene.render();\n    }\n  });\n\n\n\n};\n\n\nfunction Scene() {\n  return (\n    <SceneComponent antialias onSceneReady={onSceneReady} id=\"SceneCanvas\" />\n  );\n}\n\nexport default Scene;\n","\r\nimport * as BABYLON from \"babylonjs\";\r\nimport \"babylonjs-loaders\"\r\n\r\n\r\n\r\n/**\r\n * \r\n * @param {String} videoUrl\r\n * @param {BABYLON.Mesh} mesh \r\n * @param {Boolean} options.loop \r\n * @param {Boolean} options.autoPlay \r\n * @param {Boolean} options.autoUpdateTexture\r\n * @param {Boolean} options.muted\r\n * @param {String} options.poster   \r\n * @param {BABYLON.scene} scene \r\n */\r\nexport function VideoTextureToMesh(videoUrl, mesh, options = { loop: false, autoPlay: false, autoUpdateTexture: true, muted: false, poster: '' }, scene) {\r\n\r\n    options.loop = options.loop !== undefined ? options.loop : false;\r\n    options.autoPlay = options.autoPlay !== undefined ? options.autoPlay : false;\r\n    options.autoUpdateTexture = options.autoUpdateTexture !== undefined ? options.autoUpdateTexture : true;\r\n    options.muted = options.muted !== undefined ? options.muted : false;\r\n    options.poster = options.poster !== undefined ? options.poster : '';\r\n\r\n\r\n\r\n    let videoTexture = new BABYLON.VideoTexture(\"videoTexture\", videoUrl,\r\n        scene, true, false,\r\n        BABYLON.VideoTexture.TRILINEAR_SAMPLINGMODE, options);\r\n\r\n    let videoMaterial = new BABYLON.StandardMaterial(\"videoMat\", scene);\r\n    videoMaterial.diffuseTexture = videoTexture;\r\n    videoMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);\r\n\r\n    mesh.material = videoMaterial;\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* \r\n* @param {String} videoUrl \r\n* @param {String} audioUrl \r\n* @param {{}} videoTextureSettings \r\n* @param {{}} AudioSettings \r\n* @param {{}} videoPlaneOptions \r\n* @param {BABYLON.Scene} scene \r\n* @returns the instanced video player\r\n*/\r\nexport function VideoPlayerTexture(videoUrl, audioUrl, videoTextureSettings, AudioSettings, videoPlaneOptions, scene) {\r\n\r\n\r\n\r\n    videoTextureSettings = videoTextureSettings !== undefined ? videoTextureSettings : {\r\n        loop: false,\r\n        autoPlay: false,\r\n        autoUpdateTexture: true,\r\n        muted: true,\r\n        poster: ''\r\n    };\r\n\r\n\r\n    AudioSettings = AudioSettings !== undefined ? AudioSettings : {\r\n        loop: false,\r\n        autoPlay: false,\r\n        spatialSound: true,\r\n        distanceModel: \"exponential\",\r\n        maxDistance: 10,\r\n        refDistance: 5,\r\n        rolloffFactor: 0.8,\r\n    };\r\n\r\n    videoPlaneOptions = videoPlaneOptions !== undefined ? videoPlaneOptions : {\r\n        height: 1,\r\n        width: 1 * 1.77,\r\n        sideOrientation: BABYLON.Mesh.DOUBLESIDE\r\n    };\r\n\r\n\r\n    let videoTexture = new BABYLON.VideoTexture(\"videoTexture\", videoUrl,\r\n        scene, true, false,\r\n        BABYLON.VideoTexture.TRILINEAR_SAMPLINGMODE, videoTextureSettings);\r\n    // videoTexture.video.preload = \"auto\";\r\n    //videoTexture.XRpickable=true;\r\n\r\n    var videoPlane = BABYLON.MeshBuilder.CreatePlane(\"videoPlane\", videoPlaneOptions, scene);\r\n    var vidPos = (new BABYLON.Vector3(0, 2, 0.1))\r\n    videoPlane.position = vidPos;\r\n    videoPlane.XRpickable = true;\r\n\r\n    if (audioUrl == undefined || \"\") {\r\n        audioUrl = videoTexture.video;\r\n        videoTexture.video.muted = false;\r\n    }\r\n\r\n    const videoSound = new BABYLON.Sound(\"testSound\", audioUrl, scene, () => {\r\n        console.log(\"ready to play video sound\")\r\n\r\n    }, AudioSettings);\r\n\r\n    videoSound.attachToMesh(videoPlane);\r\n\r\n    let videoMaterial = new BABYLON.StandardMaterial(\"videoMat\", scene);\r\n    videoMaterial.diffuseTexture = videoTexture;\r\n    videoMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);\r\n    videoPlane.material = videoMaterial;\r\n\r\n\r\n    let clicked = false;\r\n\r\n    videoPlane.actionManager = new BABYLON.ActionManager(scene);\r\n    videoPlane.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {\r\n\r\n\r\n        if (clicked == false && videoSound.isReady()) {\r\n            clicked = true;\r\n            videoTexture.video.play().then(() => {\r\n                videoSound.play();\r\n            })\r\n\r\n\r\n        } else {\r\n            videoTexture.video.pause();\r\n            videoSound.pause();\r\n            clicked = false;\r\n\r\n        }\r\n    }));\r\n    \r\n    videoPlane.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnDoublePickTrigger, () => {\r\n\r\n        videoTexture.video.currentTime = 0;\r\n        videoTexture.video.pause();\r\n        videoSound.stop();\r\n\r\n    }));\r\n\r\n    return { videoTexture, videoSound, videoPlane, videoMaterial };\r\n\r\n}\r\n\r\n","export default __webpack_public_path__ + \"static/media/bus.6cd90756.gltf\";","export default __webpack_public_path__ + \"static/media/SheenChair.cccef135.glb\";","export default __webpack_public_path__ + \"static/media/videoTextureSample.0d856e14.mp4\";","export default __webpack_public_path__ + \"static/media/SonyVideoDemo.33a238ae.mp4\";","export default __webpack_public_path__ + \"static/media/rickroll.c7c91519.mp4\";","export default __webpack_public_path__ + \"static/media/software-interface-start.5b9ecb19.wav\";","export default __webpack_public_path__ + \"static/media/software-interface-back.d5d8ec22.wav\";","export default __webpack_public_path__ + \"static/media/Idle-bus.9d5a7e67.wav\";","export default __webpack_public_path__ + \"static/media/door-bus.eaf06fe9.wav\";","import * as BABYLON from \"babylonjs\";\r\nimport * as MATERIALS from \"babylonjs-materials\"\r\nimport * as GUI from \"babylonjs-gui\"\r\nimport \"babylonjs-loaders\"\r\n\r\nimport SceneComponent from \"../Babylon_components/SceneComponent\";\r\n\r\nimport ammo from \"ammo.js\"\r\n\r\nimport { showWorldAxis, showLocalAxes } from \"../Babylon_components/Axes\"\r\nimport { PlayGround } from \"../Babylon_components/PlayGround\";\r\nimport { GizmoInterface } from \"../Modules/GizmoInterface\";\r\n\r\nimport * as AV_module from \"../Modules/AV_module\";\r\nimport * as XR_Module from \"../Modules/XR_Module\";\r\n\r\nimport bus from \"../Assets/3Dmodels/bus.gltf\"\r\nimport chair from \"../Assets/3Dmodels/SheenChair.glb\"\r\n\r\nimport video1 from \"../Assets/video/SonyVideoDemo.mp4\"\r\nimport video2 from \"../Assets/video/videoTextureSample.mp4\"\r\nimport video3 from \"../Assets/video/rickroll.mp4\"\r\n\r\n\r\nimport audio_start from \"../Assets/audio/software-interface-start.wav\"\r\nimport audio_back from \"../Assets/audio/software-interface-back.wav\"\r\n\r\n\r\nimport idle_bus from \"../Assets/audio/Idle-bus.wav\"\r\nimport door_bus from \"../Assets/audio/door-bus.wav\"\r\n\r\n\r\n\r\n\r\nconst onSceneReady = async (e = { engine: new BABYLON.Engine, scene: new BABYLON.Scene, canvas: new HTMLCanvasElement }) => {\r\n\r\n    const { canvas, scene, engine } = e;\r\n\r\n    // This creates and positions a free camera (non-mesh)\r\n    var camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 5, -10), scene);\r\n    //const camera = new BABYLON.ArcRotateCamera(\"camera1\", 0, 0, 0, new BABYLON.Vector3(2, 3, 4), scene);\r\n\r\n    // This targets the camera to scene origin\r\n    camera.setTarget(BABYLON.Vector3.Zero());\r\n    //camera.setPosition(new BABYLON.Vector3(10, 3, -10))\r\n\r\n    // This attaches the camera to the canvass\r\n    camera.attachControl(canvas, false);\r\n\r\n    //scene.clearColor = new BABYLON.Color3(0, 0, 0);\r\n\r\n    scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.AmmoJSPlugin(true, await ammo()));\r\n\r\n    var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n    light.intensity = 0.7;\r\n\r\n\r\n    // Sky material\r\n    var skyboxMaterial = new MATERIALS.SkyMaterial(\"skyMaterial\", scene);\r\n    skyboxMaterial.backFaceCulling = false;\r\n\r\n    // Sky mesh (box)\r\n    var skybox = BABYLON.Mesh.CreateBox(\"skyBox\", 1000.0, scene);\r\n    skybox.material = skyboxMaterial;\r\n\r\n    skybox.material.inclination = -0.35;\r\n\r\n\r\n    showWorldAxis(8, scene);\r\n\r\n    GizmoInterface(scene);\r\n\r\n    var box = BABYLON.MeshBuilder.CreateBox(\"box\", { size: .5 }, scene);\r\n    box.position.set(2, 5, 3);\r\n\r\n    box.physicsImpostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor.BoxImpostor, { restitution: 0.1, mass: 13 }, scene);\r\n\r\n    var sphere = BABYLON.MeshBuilder.CreateSphere(\"sphere\", { diameter: .5 }, scene);\r\n    sphere.position.set(-2, 5, 3);\r\n    sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { restitution: 0.9, mass: 14 }, scene);\r\n\r\n    var playground = PlayGround({ playground_width: 100, playground_depth: 100 }, scene)\r\n    playground.ground.physicsImpostor = new BABYLON.PhysicsImpostor(playground.ground, BABYLON.PhysicsImpostor.BoxImpostor, { restitution: 0.9, mass: 0 }, scene);\r\n\r\n    box.XRpickable = true;\r\n    sphere.XRpickable = true;\r\n\r\n    var meshes = [];\r\n    meshes.push(box, sphere, skybox);\r\n\r\n    /**\r\n     * \r\n     * @param {BABYLON.Mesh} mesh mesh to add reflective texture.\r\n     * @param {[BABYLON.Mesh]} otherMeshs array of meshes to reflect.\r\n     * @param {BABYLON.Scene} scene a constructed babylon js scene.\r\n     */\r\n    function CreateReflectionTexture(mesh, otherMeshs, scene) {\r\n\r\n        // Reflection probe\r\n        var rp = new BABYLON.ReflectionProbe('ref', 512, scene);\r\n        otherMeshs.forEach(element => {\r\n\r\n            rp.renderList.push(element);\r\n        });\r\n\r\n        // PBR\r\n        var pbr = new BABYLON.PBRMaterial('pbr', scene);\r\n        pbr.reflectionTexture = rp.cubeTexture;\r\n        mesh.material = pbr;\r\n\r\n        rp.attachToMesh(mesh);\r\n\r\n    }\r\n    //CreateReflectionTexture(box, meshes, scene);\r\n    //CreateReflectionTexture(sphere, meshes, scene);\r\n\r\n    // The first parameter can be used to specify which mesh to import. Here we import all meshes\r\n\r\n    const mychair = await BABYLON.SceneLoader.ImportMeshAsync(\r\n        \"\",\r\n        chair,\r\n        \"\",\r\n        scene,\r\n        function (meshes) {\r\n\r\n        },\r\n    );\r\n\r\n    mychair.meshes[0].position = new BABYLON.Vector3(0, 0, -1);\r\n\r\n    const assetManager = new BABYLON.AssetsManager(scene);\r\n\r\n    var tasky = assetManager.addMeshTask(\"task\", \"\", bus);\r\n\r\n    tasky.onSuccess = function (task) {\r\n\r\n        //console.log(task.loadedMeshes);\r\n        task.loadedMeshes[0].position = new BABYLON.Vector3(4, 2, 3);\r\n        task.loadedMeshes[0].scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);\r\n        var collider = attachToCollider(task.loadedMeshes[0]);\r\n\r\n\r\n        var audiobusSettings = {\r\n            loop: true,\r\n            autoPlay: true,\r\n            spatialSound: true,\r\n            distanceModel: \"exponential\",\r\n            maxDistance: 10,\r\n            refDistance: 5,\r\n            rolloffFactor: 0.8,\r\n        };\r\n\r\n\r\n        var busSound = SoundSpatialToMesh(collider, idle_bus, audiobusSettings, scene);\r\n\r\n        var opendoor_sound = new BABYLON.Sound(\"door\", door_bus, scene);\r\n\r\n        collider.actionManager = new BABYLON.ActionManager(scene)\r\n        collider.actionManager.registerAction(new BABYLON.PlaySoundAction(BABYLON.ActionManager.OnPickUpTrigger, opendoor_sound));\r\n\r\n\r\n    }\r\n\r\n    tasky.onError = function (task, message, exception) {\r\n        console.log(message, exception);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {BABYLON.Mesh} mesh \r\n     * @param {String} audioUrl \r\n     * @param {*} options.loop\r\n     * @param {*} options.autoPlay\r\n     * @param {*} options.spatialSound\r\n     * @param {*} options.distanceModel\r\n     * @param {*} options.maxDistance\r\n     * @param {*} options.refDistance\r\n     * @param {*} options.rolloffFactor\r\n     * @param {*} scene \r\n     */\r\n    function SoundSpatialToMesh(mesh, audioUrl, options = { loop: false, autoPlay: false, spatialSound: true, distanceModel: \"exponential\", maxDistance: 10, refDistance: 5, rolloffFactor: 0.8, }, scene) {\r\n\r\n        const sound = new BABYLON.Sound(mesh.name + \"_sound\", audioUrl, scene, () => {\r\n            console.log(\"ready to play video sound: \" + audioUrl)\r\n            sound.play();\r\n\r\n        }, options);\r\n\r\n        sound.attachToMesh(mesh);\r\n\r\n        return sound;\r\n    }\r\n\r\n\r\n    /**\r\n     * Function to atach a (box mesh) collider with physics and interaction capabilities\r\n     * @param {BABYLON.Mesh} rootMesh \r\n     * @returns \r\n     */\r\n    function attachToCollider(rootMesh) {\r\n\r\n        var collider = BABYLON.MeshBuilder.CreateBox(rootMesh.name + \"_collider\", { height: 1, width: 1, depth: 1 }, scene);\r\n        collider.XRpickable = true;\r\n\r\n        var boundingMinMax = rootMesh.getHierarchyBoundingVectors();\r\n        var bounds = boundingMinMax.max.subtract(boundingMinMax.min);\r\n        var geometricCenter = boundingMinMax.max.add(boundingMinMax.min).scale(0.5);\r\n\r\n        collider.scaling.copyFrom(bounds);\r\n        collider.visibility = 0;\r\n        collider.physicsImpostor = new BABYLON.PhysicsImpostor(collider, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 99 }, scene);\r\n        collider.position = geometricCenter;\r\n\r\n        rootMesh.setParent(collider);\r\n\r\n        return collider;\r\n\r\n    }\r\n\r\n    assetManager.load();\r\n\r\n\r\n\r\n    var videoSize = 1;\r\n\r\n    let videoTextureSettings = {\r\n        loop: false,\r\n        autoPlay: false,\r\n        autoUpdateTexture: true,\r\n        muted: true,\r\n        poster: ''\r\n    };\r\n\r\n    var AudioSettings = {\r\n        loop: false,\r\n        autoPlay: false,\r\n        spatialSound: true,\r\n        distanceModel: \"exponential\",\r\n        maxDistance: 10,\r\n        refDistance: 5,\r\n        rolloffFactor: 0.8,\r\n    };\r\n\r\n    var videoPlaneOptions = {\r\n        height: videoSize,\r\n        width: videoSize * 1.77,\r\n        sideOrientation: BABYLON.Mesh.DOUBLESIDE\r\n    };\r\n\r\n\r\n\r\n    var videoplayer = AV_module.VideoPlayerTexture(video3, null, videoTextureSettings, AudioSettings, videoPlaneOptions, scene);\r\n    //videoplayer.videoSound.attachToMesh(collider);\r\n\r\n\r\n\r\n    let videoCube = BABYLON.MeshBuilder.CreateBox(\"videocube\", { size: 2 }, scene);\r\n    videoCube.position = new BABYLON.Vector3(0, 1, 4);\r\n    videoCube.physicsImpostor = new BABYLON.PhysicsImpostor(videoCube, BABYLON.PhysicsImpostor.BoxImpostor, { restitution: 0.9, mass: 1 }, scene);\r\n    videoCube.XRpickable = true;\r\n\r\n\r\n    videoCube.actionManager = new BABYLON.ActionManager(scene)\r\n    videoCube.actionManager.registerAction(new BABYLON.PlaySoundAction(BABYLON.ActionManager.OnPickUpTrigger, new BABYLON.Sound(\"up\", audio_back, scene)));\r\n\r\n    videoCube.actionManager.registerAction(new BABYLON.PlaySoundAction(BABYLON.ActionManager.OnPickDownTrigger, new BABYLON.Sound(\"down\", audio_start, scene)));\r\n\r\n    AV_module.VideoTextureToMesh(video2, videoCube, { loop: true, autoPlay: true, muted: true }, scene);\r\n\r\n\r\n\r\n\r\n    var mesheswithShadows = [box,sphere];\r\n\r\n    XR_Module.XR_Experience(playground.ground,skybox,mesheswithShadows,scene);\r\n\r\n\r\n    engine.runRenderLoop(() => {\r\n        if (scene) {\r\n          scene.render();\r\n        }\r\n      });\r\n\r\n\r\n}\r\n\r\n\r\nfunction Scene() {\r\n\r\n\r\n    return (\r\n        <SceneComponent antialias onSceneReady={onSceneReady} />\r\n\r\n    );\r\n}\r\n\r\nexport default Scene;\r\n","import * as BABYLON from \"babylonjs\";\r\nimport * as MATERIALS from \"babylonjs-materials\"\r\nimport * as GUI from \"babylonjs-gui\"\r\nimport 'babylonjs-loaders';\r\n\r\nimport SceneComponent from \"../Babylon_components/SceneComponent\";\r\n\r\n\r\nimport { showWorldAxis, showLocalAxes } from \"../Babylon_components/Axes\"\r\nimport { PlayGround } from \"../Babylon_components/PlayGround\";\r\nimport { GizmoInterface } from \"../Modules/GizmoInterface\";\r\n\r\nimport * as XR_Module from \"../Modules/XR_Module\";\r\n\r\nimport ammo from \"ammo.js\"\r\n\r\n\r\n\r\nconst onSceneReady = async (e = { engine: new BABYLON.Engine, scene: new BABYLON.Scene, canvas: new HTMLCanvasElement }) => {\r\n\r\n    const { canvas, scene, engine } = e;\r\n\r\n    // This creates and positions a free camera (non-mesh)\r\n    var camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 5, -10), scene);\r\n    //const camera = new BABYLON.ArcRotateCamera(\"camera1\", 0, 0, 0, new BABYLON.Vector3(2, 3, 4), scene);\r\n\r\n    // This targets the camera to scene origin\r\n    camera.setTarget(BABYLON.Vector3.Zero());\r\n    //camera.setPosition(new BABYLON.Vector3(10, 3, -10))\r\n\r\n    // This attaches the camera to the canvass\r\n    camera.attachControl(canvas, false);\r\n\r\n    //scene.clearColor = new BABYLON.Color3(0, 0, 0);\r\n\r\n    scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.AmmoJSPlugin(true, await ammo()));\r\n\r\n   \r\n    // Skybox\r\n    /*var skybox = BABYLON.MeshBuilder.CreateBox(\"skyBox\", {size:1000.0}, scene);\r\n    var skyboxMaterial = new BABYLON.StandardMaterial(\"skyBox\", scene);\r\n    skyboxMaterial.backFaceCulling = false;\r\n    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(spacebox, scene);\r\n    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;\r\n    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);\r\n    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);\r\n    skybox.material = skyboxMaterial;\t*/\r\n\r\n    // Sky material\r\n    var skyboxMaterial = new MATERIALS.SkyMaterial(\"skyMaterial\", scene);\r\n    skyboxMaterial.backFaceCulling = false;\r\n\r\n    // Sky mesh (box)\r\n    var skybox = BABYLON.Mesh.CreateBox(\"skyBox\", 1000.0, scene);\r\n    skybox.material = skyboxMaterial;\r\n\r\n    skybox.material.inclination = -0.35;\r\n\r\n\r\n    showWorldAxis(8, scene);\r\n\r\n    GizmoInterface(scene);\r\n\r\n    var box = BABYLON.MeshBuilder.CreateBox(\"box\", { size: 0.2 }, scene);\r\n    box.position.y = 5;\r\n\r\n    box.physicsImpostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor.BoxImpostor, { restitution: 0.1, mass: 13 }, scene);\r\n\r\n    var sphere = BABYLON.MeshBuilder.CreateSphere(\"sphere\", { diameter: 0.4 }, scene);\r\n    sphere.position.set(0, 5, 3);\r\n    sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { restitution: 0.9, mass: 14 }, scene);\r\n\r\n    box.XRpickable = true;\r\n    sphere.XRpickable = true;\r\n\r\n\r\n    var playground = PlayGround({ playground_width: 100, playground_depth: 100 }, scene)\r\n    playground.ground.physicsImpostor = new BABYLON.PhysicsImpostor(playground.ground, BABYLON.PhysicsImpostor.BoxImpostor, { restitution: 0.9, mass: 0 }, scene);\r\n\r\n    \r\n    var ground_base_color = new BABYLON.StandardMaterial(\"ground_base_color\", scene)\r\n    ground_base_color.diffuseColor =  new BABYLON.Color3(1,1,1);\r\n\r\n  \r\n    const shadowMaterial = new MATERIALS.ShadowOnlyMaterial('shadowOnly', scene);\r\n\r\n    playground.ground.material = shadowMaterial;\r\n    //playground.ground.material = ground_base_color;\r\n\r\n    playground.ground.receiveShadows = true;\r\n\r\n    var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n    //light.intensity = 0.7;\r\n\r\n\r\n    var sphere1 = BABYLON.MeshBuilder.CreateSphere(\"sphere\", { diameter: 0.2, segments: 32 }, scene);\r\n    var sphere2 = BABYLON.MeshBuilder.CreateSphere(\"sphere\", { diameter: 0.2, segments: 32 }, scene);\r\n    var sphere3 = BABYLON.MeshBuilder.CreateSphere(\"sphere\", { diameter: 0.2, segments: 32 }, scene);\r\n\r\n    sphere1.material = new BABYLON.PBRMaterial('metal', scene);\r\n    sphere1.material.roughness = 0.25;\r\n    sphere1.material.metallic = 1.0;\r\n    sphere1.material.realTimeFiltering = true;\r\n    sphere1.material.realTimeFilteringQuality = BABYLON.Constants.TEXTURE_FILTERING_QUALITY_HIGH;\r\n    sphere1.position.y = 0.1;\r\n    // sphere.position.z = 1;\r\n\r\n    sphere2.setPivotMatrix(BABYLON.Matrix.Translation(0.2, 0.1, 0), false);\r\n    sphere2.material = new BABYLON.PBRMaterial('metal', scene);\r\n    sphere2.material.albedoColor = new BABYLON.Color3(0.8, 0.0, 0.3);\r\n    sphere2.material.roughness = 0.1;\r\n    sphere2.material.metallic = 0.0;\r\n\r\n    sphere3.setPivotMatrix(BABYLON.Matrix.Translation(0.4, 0.1, 0), false);\r\n    sphere3.material = new BABYLON.PBRMaterial('metal', scene);\r\n    sphere3.material.roughness = 0.1;\r\n    sphere3.material.metallic = 0.3;\r\n    sphere3.material.albedoColor = new BABYLON.Color3(0.3, 0.0, 0.8);\r\n\r\n    scene.registerBeforeRender(function () {\r\n        sphere2.rotation.y += 0.01;\r\n        sphere3.rotation.y += 0.01;\r\n    });\r\n\r\n    \r\n    var meshes = [];\r\n    meshes.push(box, sphere, skybox);\r\n\r\n    var mesheswithShadows = [];\r\n    mesheswithShadows.push(box,sphere,sphere1,sphere2,sphere3);\r\n\r\n    /**\r\n     * \r\n     * @param {BABYLON.Mesh} mesh mesh to add reflective texture.\r\n     * @param {[BABYLON.Mesh]} otherMeshs array of meshes to reflect.\r\n     * @param {BABYLON.Scene} scene a constructed babylon js scene.\r\n     */\r\n    function CreateReflectionTexture(mesh, otherMeshs, scene) {\r\n\r\n        // Reflection probe\r\n        var rp = new BABYLON.ReflectionProbe('ref', 512, scene);\r\n        otherMeshs.forEach(element => {\r\n\r\n            rp.renderList.push(element);\r\n        });\r\n\r\n        // PBR\r\n        var pbr = new BABYLON.PBRMaterial('pbr', scene);\r\n        pbr.reflectionTexture = rp.cubeTexture;\r\n        mesh.material = pbr;\r\n\r\n        rp.attachToMesh(mesh);\r\n\r\n    }\r\n    //CreateReflectionTexture(box, meshes, scene);\r\n    //CreateReflectionTexture(sphere, meshes, scene);\r\n\r\n\r\n    const XR_experience = XR_Module.XR_Experience(playground.ground, skybox, mesheswithShadows, scene);\r\n\r\n\r\n    engine.runRenderLoop(() => {\r\n        if (scene) {\r\n          scene.render();\r\n        }\r\n      });\r\n\r\n}\r\n\r\n\r\nfunction Scene() {\r\n\r\n\r\n    return (\r\n        <SceneComponent antialias onSceneReady={onSceneReady} />\r\n\r\n    );\r\n}\r\n\r\nexport default Scene;\r\n","import './App.css';\n\nimport {BrowserRouter as Router, Routes, Route} from \"react-router-dom\"\n\nimport INTRO from \"./Scenes/intro\"\nimport TEMA_1 from \"./Scenes/tema_1_figuras\"\nimport TEMA_2 from \"./Scenes/tema_2_posicion_rotacion_escala\"\nimport TEMA_3 from \"./Scenes/tema_3_transformaciones\"\nimport TEMA_4 from \"./Scenes/tema_4_assets_interacciones\"\nimport TEMA_5 from \"./Scenes/tema_5_webxr\"\n\n\nfunction App() {\n  return (\n    <Router>\n      <Routes>\n          <Route exact path='/' element={<INTRO/>}></Route>\n          <Route path='/tema_1' element={<TEMA_1/>}></Route>\n          <Route path='/tema_2' element={<TEMA_2/>}></Route>\n          <Route path='/tema_3' element={<TEMA_3/>}></Route>\n          <Route path='/tema_4' element={<TEMA_4/>}></Route>\n          <Route path='/tema_5' element={<TEMA_5/>}></Route>\n      </Routes>\n    </Router>\n)}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  //<React.StrictMode>\n  <App />\n  //</React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}